{{ define "main" }}
<div class="single-content-area">
    
    <div style="height: 10px;"></div>
    <div id="discoverSpinner" style="text-align: center;">
        Fetching learning materials...
    </div>

    <div class="feature-title-container learn-title">
        <div class="feature-title">{{ .Page.Title }}</div>
        {{ if eq (int .Site.Params.latestRhinoVersion) (int .Params.included_in.since) }}<div class="new-callout"><a
                href="/{{ .Site.Params.latestRhinoVersion}}/new">{{ i18n "NEW-in-Vx" . }}</a></div>
        {{ end }}{{- partial "platform-callout" . -}}
    </div>
    <div id="discoverGallery" class="discover-gallery">
        <div class="toc discover-filters-box">
            <ul class="discover-filters">
                <li class="discover-filter"
                    v-bind:class="{ discoverFilterGray: !kind.isNew, discoverFilterRed: kind.isNew }"
                    v-for="kind in cardKinds" v-on:click="filterCardsByKind" v-bind:kind="(( kind.query ))">
                    <span style="display: inline-block; padding: 2px 10px 2px 10px; user-select: none;" >(( kind.title ))</span>
                    <img v-if="kind.isFeat" class="discover-filter-featured-icon"
                        src="/images/learn/featured-icon.svg" />
                    <div v-if="kind.isNew" id="unmarkall" class="discover-unmarkall" v-on:click="forgetAllItems"
                        title="Unmark All">
                        <img class="discover-filter-new-icon" src="/images/learn/check.svg" />
                    </div>
                </li>
            </ul>
        </div>
        <div>

            <!-- Modal -->
            <div class="modal fade" id="ModalCenter" tabindex="-1" role="dialog" aria-labelledby="ModalCenterTitle" aria-hidden="true">
                <div class="modal-dialog modal-dialog-centered" role="document">
                <div class="modal-content"  v-if="selectedCard">
                    <div class="modal-header">
                        <p class="modal-title" id="ModalLongTitle">((selectedCard.title))</p>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                    </div>
                    <div class="modal-body">
                        <iframe v-if="!selectedCard.embedUrl.includes('rhino3d.com/static-media/video')" width='100%' height='400px' v-bind:src="selectedCard.embedUrl" frameborder='0' allow="autoplay; fullscreen" allowFullScreen></iframe>

                        <div class="video-player" v-else>
                            <div class="caption-locator">
                            <center>
                                    <span class="rma-caption" style="display:none;"></span>
                            </center>
                            </div>
                            
                            <video id="video" controls="" autoplay="" loop="" playsinline="" muted="" preload="metadata" style="width:100%">
                                <source v-bind:src="selectedCard.embedUrl">
                                <track kind="metadata" srclang="{{.Site.Language.Lang}}" v-bind:src="`${selectedCard.embedUrl.substr(0, selectedCard.embedUrl.lastIndexOf('/'))}/{{.Site.Language.Lang}}.vtt`" default="">
                            </video>
                        </div>
                        
                    </div>
                    <div class="modal-footer" >
                            (( selectedCard.description ))
                    </div>
                </div>
                </div>
            </div>

            <input id="querybox" class="discover-search" type="text" placeholder='{{ i18n "filter" }}' v-model.trim="query" style="display: none;"/>
            <div id="tagbox" class="learn-tagbox-hidden" >
                <span  class="discover-info-tag " v-on:click="toggleTagsOverflow()">
                    <i class="fa fa-chevron-down" ></i>
                </span>
            <div v-for="(tag, index) in currentTags" :key="tag" style="cursor: pointer; background-color: rgb(92, 92, 92); color: white;" class="discover-info-tag" v-on:click="removeTag(tag)">
                (( tagMap && tagMap[tag] ? tagMap[tag].title : tag ))
            </div>
            <div v-for="(tag, index) in availableTags" :key="tag" style="cursor: pointer; background-color: #eee;"  class="discover-info-tag" v-on:click="addTag(tag)">
                (( tagMap && tagMap[tag] ? tagMap[tag].title : tag ))
            </div>
            </div>
            <input id="searchbox" class="discover-search" type="text" placeholder='{{ i18n "filter" }}' v-model.trim="keyword"/>
            <div style="width: 800px; margin:auto; text-align:center; padding:24px" v-if="discoverCards.length==0">
                Nothing to show
                <span style="color:#900; cursor:pointer" v-on:click="resetQuery()">Reset filters</span>
            </div>

            <!-- healthcheck, internal mcneel only -->
            <div class="mcneel_only hidden">
                <div style="display: flex; justify-content: space-between; align-items: center; background-color: antiquewhite;padding: 10px;border-radius: 5px;">
                    <strong>Admin tools (McNeel only):</strong>
                    <button v-on:click="linkHealthCheckModal()" >Check links health</button>
                    <div class="modal fade" id="HealthCheckModal" tabindex="-1" role="dialog" aria-labelledby="ModalCenterTitle" aria-hidden="true">
                        <div class="modal-dialog modal-dialog-centered" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                                <p class="modal-title" id="ModalLongTitle">Check links health</p>
                            <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                                <span aria-hidden="true">&times;</span>
                            </button>
                            </div>
                            <div class="modal-body">
                                <p>Ignore links from following domains</p>
                                <ul>
                                    <li v-for="(value, name, index) in linkCheckIgnores">
                                        <input type="checkbox" v-model="linkCheckIgnores[name]"  v-bind:id="name">
                                        <span>(( name ))</span>
                                    </li>
                                </ul>
                                <p>((linksToCheck.length)) Links to check:</p>
                                {{/*  <ul>
                                    <li v-for="link in linksToCheck">
                                        <a :href="'https://www.whatsmydns.net/redirect-checker?q='+link" target="_blank">((link))</a>
                                    </li>
                                </ul>  */}}
                                <p>
                                    <b>Redirected links need to be manually checked:</b>
                                    <br/>
                                    If a link is no longer relevant, it should be removed from learn.toml
                                    <br/>
                                    If it is still relevant, you can put a new key <span><b>verified = "mm/dd/yyyy"</b></span> under <span><b>[[tutorials]]</b></span> for that link in learn.toml so I know to ignore them in future checks
                                </p>
                                <div style="text-align: center;" v-if="checkingLinkHealthInProgress">
                                    Please Wait...
                                </div>
                                <ol style="overflow-wrap: anywhere;">
                                    <template v-for="item in redirectedLinks">
                                        <li v-if="item">
                                            <div v-for="[link, details] of Object.entries(item)">
                                                <a :href="link" target="_blank">(( link ))</a>
                                                <template v-for="step,i in details.steps">
                                                    <p :style="`padding-left: ${i*15}px;`">â†˜ ((step.status)) ((step.url))</p>
                                                </template>
                                                <a :href="details.destination_url" target="_blank">((details.destination_url))</a>
                                            </div>
                                            <br/>
                                        </li>
                                    </template>
                                </ol>
                            </div>
                        </div>
                        </div>
                    </div>
                </div>
            </div>

            <div  class="discover-grid discover-grid-row" v-if="discoverCards.length>0">
                <div v-for="card in discoverCards"  v-bind:itemid="card.url"
                    class="discover-item card learn-card-override">
                    <a v-bind:itemid="card.url" v-on:click="handleCardOpen">
                        <div class="discover-thumbnail discover-thumbnail-dim">
                            <img class="discover-img no-popup" v-bind:src="card.thumbnail"/>
                        </div>
                    </a>
                    <div class="discover-info">

                        <a class=" discover-info-title" v-bind:itemid="card.url" v-on:click="handleCardOpen">(( card.title ))</a>
                        <a class="discover-info-author" v-on:click="handleAuthorClick(card.author)">((
                            card.author))</a>
                        {{/*  <div class="discover-feature-badge" v-if="card.highlight">
                            <img src="/images/learn/featured-badge.svg" />
                        </div>  */}}
                        <div class="discover-info-subtitle">
                            (( card.subtitle ))
                        </div>
                        <ul class="discover-info-tags discover-info-tags-short">
                            <li v-for="kind in card.kinds" v-bind:kind="(( kind.query ))"
                                v-on:click="filterCardsByKind" class="discover-info-kindtag">
                                (( kind.title ))
                            </li>
                            <li v-for="tag in card.tags" v-bind:tag="(( tag ))" v-on:click="filterCardsByTag"
                                class="discover-info-tag">
                                (( tagMap && tagMap[tag] ? tagMap[tag].title : tag ))
                            </li>
                        </ul>
                        <div class="discover-info-extra" v-html="card.description" />
                    </div>

                </div>
            </div>
        </div>
    </div>
</div>


<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js" integrity="sha384-jLwhcmGu/RL8PSTUEl/559f8QVLL4QqM+HBvoZlt4F7XCdsdoDGAwW4nPFfoM7lU" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js"
    integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous">
</script>
<script src='{{ (resources.Get "/script/vue-2.6.10.min.js" | resources.Fingerprint).Permalink }}'></script>
<script src='{{ (resources.Get "/script/markdown-0.5.0.min.js" | resources.Fingerprint).Permalink }}'></script>
<script type="text/javascript" src='{{ (resources.Get "/script/fast-toml.js" | resources.Fingerprint).Permalink }}'>
</script>
<script src="https://cdn.jsdelivr.net/npm/fuzzysort@2.0.1/fuzzysort.min.js" integrity="sha384-/AGrezUaKQXXMlRybn/0egtqO3/JjMrXCpEK51HoVJGvQ3mScXfD0/pK5Qi+89P6" crossorigin="anonymous"></script>
{{/*  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>  */}}
<!-- <script type="text/javascript" src="{{ (resources.Get "/script/yaml.min.js" | resources.Fingerprint).Permalink }}"> -->
<!-- </script> -->

<script>
    var authorData = JSON.parse("{{ jsonify $.Site.Data.authors }}");

    function lookupAuthor(authorId) {
        if (authorData[authorId]) {
            var authorInfo = authorData[authorId];
            if (authorInfo.display_name){
                return authorInfo.display_name;
            }
            else{
                return authorInfo.name;
            }
        }
    }
</script>

<script>
    const siteBase = "{{ .Site.BaseURL }}";
    const pageLang = "{{ .Language.Lang }}";
    const isProduction = "{{ if hugo.IsProduction }}1{{ else }}0{{ end }}";
    const urlParams = new URLSearchParams(window.location.search);

    function titleCase(str) {
        str = str.toLowerCase().split(' ');
        for (var i = 0; i < str.length; i++) {
            str[i] = str[i].charAt(0).toUpperCase() + str[i].slice(1);
        }
        return str.join(' ');
    }

    function getForgottenItems() {
        if (typeof (Storage) !== 'undefined') {
            return JSON.parse(window.localStorage.getItem("forgottenItems"))
        }
        return null;
    }

    function setForgottenItems(items) {
        if (typeof (Storage) !== "undefined") {
            let updatedItems = items;
            var forgottenItems = getForgottenItems();
            if (forgottenItems != undefined) {
                forgottenItems = [].concat(forgottenItems, items);
                forgottenItems = new Set(forgottenItems);
                updatedItems = Array.from(forgottenItems);
            }
            window.localStorage.setItem("forgottenItems", JSON.stringify(updatedItems));
        }
    }

    function selectItems(items) {
        if (window.maxItems != undefined && items.length >= window.maxItems) {
            return items.slice(0, window.maxItems);
        }

        return items;
    }

    function toggleTagsOverflow() {
        $("#tagbox").toggleClass("learn-tagbox-hidden learn-tagbox-expanded");
    }

    function attachDiscoverItemHover(cards) {
        cards.hover(function () {
            $(this).find(".discover-info-new-ok").css("display", "inline-block")
            $(this).addClass("discover-item-focused");
            $(this).find(".discover-thumbnail").removeClass("discover-thumbnail-dim");
            $(this).find(".discover-info-extra").addClass("discover-info-extra-open");
            $(this).find(".discover-info-tags").removeClass("discover-info-tags-short");
        }, function () {
            $(this).find(".discover-info-new").css("padding-right", "5px")
            $(this).find(".discover-info-new-ok").css("display", "none")
            $(this).removeClass("discover-item-focused");
            $(this).find(".discover-thumbnail").addClass("discover-thumbnail-dim");
            $(this).find(".discover-info-extra").removeClass("discover-info-extra-open");
            $(this).find(".discover-info-tags").addClass("discover-info-tags-short");
        });
    };

    function hideCardKind(cards) {
        cards.each((i, c) => {
            $(c).find(".discover-info-kindtag").css("display", "none")
        });
    }

    function showCardKind(cards) {
        cards.each((i, c) => {
            $(c).find(".discover-info-kindtag").css("display", "inline-block")
        });
    }

    function forgetItems(cards) {
        var forgottenItems = [];
        cards.each((i, c) => {
            forgottenItems.push($(c).attr("itemid"));
        });
        setForgottenItems(forgottenItems);
    }

    function updateNewItems(cards) {
        var forgottenItems = getForgottenItems() || [];
        var atLeastOneNew = false;
        cards.each((i, c) => {
            var item = $(c);
            var newMarker = item.find(".discover-info-new");
            if (!forgottenItems.includes(item.attr("itemid"))) {
                newMarker.css("display", "block");
                atLeastOneNew = true;
            } else {
                newMarker.css("display", "none");
            }
        });
        if (atLeastOneNew) {
            $("#unmarkall").css("display", "inline-block");
        } else {
            $("#unmarkall").css("display", "none");
        }
    }

    async function getDiscoverCards(filter) {
        var dataUrl;
        var localDataUrl;
        if (isProduction == "1")
            {
                dataUrl = `${window.location.origin}/${pageLang}/learn/learn.toml`;
                localDataUrl = `${window.location.origin}/${pageLang}/learn/learn-${pageLang}.toml`;
            }
        else
            {
                dataUrl = `${window.location.origin}/${pageLang}/learn/learn.toml`;
                localDataUrl = `${window.location.origin}/${pageLang}/learn/learn-${pageLang}.toml`;
            }
        const res = await fetch(dataUrl);
        const localRes = await fetch(localDataUrl);

        let combinedLearnData;
        if (res.ok) {
            combinedLearnData = TOML.parse(await res.text());
        }
        if (localRes.ok) {
            localLearnData = TOML.parse(await localRes.text());
            if (localLearnData["tutorials"]){
                combinedLearnData = {...combinedLearnData, tutorials:[...localLearnData["tutorials"], ...combinedLearnData["tutorials"]]}
            }
        }
        return combinedLearnData
    };

    function removeURLParameter(url, parameter) {
        //prefer to use l.search if you have a location/link object
        var urlparts = url.split('?');   
        if (urlparts.length >= 2) {
    
            var prefix = encodeURIComponent(parameter) + '=';
            var pars = urlparts[1].split(/[&;]/g);
    
            //reverse iteration as may be destructive
            for (var i = pars.length; i-- > 0;) {    
                //idiom for string.startsWith
                if (pars[i].lastIndexOf(prefix, 0) !== -1) {  
                    pars.splice(i, 1);
                }
            }
    
            return urlparts[0] + (pars.length > 0 ? '?' + pars.join('&') : '');
        }
        return url;
    }

    Vue.options.delimiters = ['((', '))'];

    var app;

    getDiscoverCards().then((learnData) => {

        //check if data structure of toml is the old version
        tomlIsOld = learnData["kinds"] ? false : true

        var cards = new Array();
        var kinds = new Array();

        if (tomlIsOld){
            kinds.push({
                title: '{{ i18n "all" }}',
                query: "all",
            });  
    
            var groups = new Array();
            for (const group in learnData) {
                groups.push(group);
            }
            // sort kinds by weight
            groups.sort((a, b) => learnData[a]["weight"] - learnData[b]["weight"]);
    
            // build the card data
            groups.forEach((g) => {
                var groupId = g;
                var groupObj = learnData[g];
                var groupTitle = groupObj['title'];
                var kind = {
                    title: groupTitle,
                    query: groupId
                }
                kinds.push(kind);
                tutorials = groupObj['tutorial'];
                if (tutorials != undefined) {
                    tutorials.forEach((t) => {
                        t['kinds'] = new Array(kind);
                        if (t['author'] != undefined) {
                            t['author'] = lookupAuthor(t['author']);
                        } else {
                            t['author'] = lookupAuthor("support");
                        }
                        cards.push(t);
                    })
                }
            });
        }
        else
        {
            for (const [key, value] of Object.entries(learnData["kinds"])) {
                kind = {
                    title: value["title"],
                    query: key
                }
                kinds.push(kind);
            }

            kinds.sort((a, b) => learnData["kinds"][a["query"]]["weight"] - learnData["kinds"][b["query"]]["weight"]);

            kindAll = {
                title: '{{ i18n "all" }}',
                query: "all",
            };
            kinds.splice(0, 0, kindAll);

            tutorials = learnData['tutorials'];
            if (tutorials != undefined) {
                tutorials.forEach((t) => {
                    tKinds = t["kinds"].map(k => {
                        return {query: k, title: learnData["kinds"][k]["title"]}
                    })
                    t["kinds"] = tKinds;
                    if (t['author'] != undefined) {
                        t['author'] = lookupAuthor(t['author']);
                    } else {
                        t['author'] = lookupAuthor("support");
                    }
                    cards.push(t);
                })
            }
        }

        var defaultQuery = undefined;
        //const platform = window.navigator.platform;
        // Mac* is all mac platforms
        //if (platform.startsWith("Mac")) {
        //    defaultQuery = "kind: rhino_mac";
        //}
        // Win* is all windows platforms
        //else if (platform.startsWith("Win")) {
        //    defaultQuery = "kind: rhino_win";
        //}
        // assume *nix
        //else {
            // use rhino_jump_start since we don't support *nix right now
            defaultQuery = "kind: jump_start";
        //}

        app = new Vue({
            el: '#discoverGallery',
            data: {
                query: '',
                tagMap: learnData["tags"],
                currentTags: [],
                currentKinds: [],
                availableTags: [],
                keyword: '',
                defaultQuery: defaultQuery,
                pushNewState: true,
                showKindTags: false,
                cardKinds: kinds,
                allCards: cards,
                discoverCards: [],
                selectedCard: null,
                modalContent: null,
                linkCheckIgnores: {
                    "mcneel.com": true,
                    "rhino3d.com": true,
                    "vimeo.com": true,
                    "youtube.com": true,
                    "youtu.be": true
                },
                linksToCheck: learnData["tutorials"].map(t => t.url),
                redirectedLinks: [],
                checkingLinkHealthInProgress: false
            },
            methods: {
                filterCardsByKind: function (event) {
                    let kind = event.currentTarget.getAttribute('kind');
                    this.internalFilter = true;
                    this.currentKinds = [kind];
                },
                filterCardsByTag: function (event) {
                    let tag = event.currentTarget.getAttribute('tag');
                    this.internalFilter = true;
                    if (!this.currentTags.includes(tag)){
                        this.currentTags.push(tag);
                    }
                    window.scrollTo(0, 0);
                    $("#querybox").focus();
                },
                resetQuery: function (event) {
                    this.query = defaultQuery;
                },
                linkHealthCheckModal: function (event){
                    $('#HealthCheckModal').modal();
                    this.linkHealthCheck(this.linkCheckIgnores);
                },
                linkHealthCheck: function (ignoreLinksFrom){
                    this.checkingLinkHealthInProgress = true;
                    var ignoredDomains = [];
                        Object.keys(ignoreLinksFrom).forEach(function(key, index) {
                            if (ignoreLinksFrom[key]){
                                ignoredDomains.push(key)
                            }
                        });
                        this.linksToCheck = learnData["tutorials"].map(t => t.url).filter(l =>{
                            const shouldIgnore = ignoredDomains.some(d => l.includes(d));
                            return !shouldIgnore
                        })

                        //TODO: check url redirect counts
                        axios.post('https://www.rhino3d.com/www-api/utils/redirect-checker', this.linksToCheck).then( r =>{
                            const data = r.data;

                            const redirectMaps = Object.keys(data).map( url => {
                                const d = data[url]
                                if (d["redirected"]){
                                    return {[url]:d}
                                }
                            })
                            this.redirectedLinks=redirectMaps
                            this.checkingLinkHealthInProgress = false;
                        }).catch(e => {
                            this.checkingLinkHealthInProgress = false;
                        })
  
                },
                forgetItem: function (event) {
                    let itemId = event.currentTarget.getAttribute('itemid');
                    setForgottenItems(new Array(itemId));
                    let discoverCards = $(".discover-item");
                    updateNewItems(discoverCards);
                },
                getEmbedUrl: function(url){
                    embedUrl = ""
                    subtitles = pageLang == "en" ? "None" : pageLang
                    url = url.replace(/\/$/, '');
                    console.log("url:", url)
                    if (url.startsWith("https://vimeo.com/") || url.startsWith("http://vimeo.com/")){
                        if (url.includes("showcase") && !url.includes("video") ){
                            return;
                        }
                        else if(url.includes("ondemand")){
                            return;
                        }
                        else if(url == "https://vimeo.com/rhino/videos"){
                            return;
                        }
                        else{
                            videoId = url.substring(url.lastIndexOf('/') + 1);
                            embedUrl = "https://player.vimeo.com/video/"+videoId+"?autoplay=1&texttrack="+subtitles;
                        }
                    }
                    if (url.startsWith("https://youtube.com/") || url.startsWith("http://youtube.com/") || url.startsWith("https://youtu.be/") || url.startsWith("http://youtu.be/")){
                        if (url.includes("/user/")){
                            return;
                        }
                        else if (url.includes("/playlist")){
                            return;
                        }
                        else{
                        videoId = url.substring(url.lastIndexOf('/') + 1);
                        embedUrl = "https://www.youtube.com/embed/"+videoId+"?autoplay=1";
                        }

                    }
                    if (url.startsWith("https://www.rhino3d.com/static-media/video")){
                        embedUrl = url;
                    }
                    return embedUrl;
                },
                handleCardOpen: function (event) {
                    const cardElement = event.currentTarget;
                    const url = cardElement.getAttribute('itemid');
                    embeddable = this.getEmbedUrl(url);
                    //Hard coding playlist detection because line above fails in production
                    console.log(url,"includes playlist",url.includes("playlist"))
                    if (url.includes("playlist")){
                        console.log("Youtube playlist failsafe")
                        embeddable = false
                    }
                    console.log("Embed URL:", embeddable)
                    if(embeddable){
                        this.modalContent = url;
                    }
                    else{
                        if (url.includes("download.mcneel.com")) {
                            console.log("downloading pdf assign");
                            window.location.assign(url);
                        }
                        else {
                            window.open(url, '_blank').focus();
                        }
                    }
                    this.forgetItem(event);
                },
                handleAuthorClick: function (author) {
                    this.keyword = author;
                },
                forgetAllItems: function (event) {
                    if (window.confirm("Are you sure you want to unmark all new items?")) {
                        let discoverCards = $(".discover-item");
                        forgetItems(discoverCards);
                        updateNewItems(discoverCards);
                    }
                    event.cancelBubble = true;
                },
                addTag: function (tag) {
                    if (!this.currentTags.includes(tag)){
                        this.currentTags.push(tag);
                    }
                },
                removeTag: function (tag) {
                    const index = this.currentTags.indexOf(tag);
                    if (index > -1) {
                        this.currentTags.splice(index, 1); 
                    }
                },

                createQuery: function (kinds, tags, keyword){
                    this.internalFilter = true;
                    query = "";
                    if (kinds.length>0){
                        query+= 'kind: '+kinds.map(kind=>kind.toLowerCase()).join(",");
                    }
                    if (tags.length>0){
                        query+= ' tag: '+tags.map(tag=>tag.toLowerCase()).join(",");
                    }
                    if (keyword.length>0){
                        query+= " "+keyword;
                    }
                    this.query = query;
                }
            },
            watch: {
                currentTags: function (tags) {
                    this.createQuery(this.currentKinds, tags, this.keyword);
                },
                currentKinds: function (kinds) {
                    $('.discover-filter').each(function () {
                        var df = $(this);
                        if (kinds.includes(df.attr('kind'))) {
                            df.addClass('active-filter');
                        }
                        else{
                            df.removeClass('active-filter');
                        }
                    });
                    this.createQuery(kinds, this.currentTags, this.keyword);
                },
                keyword: function (keyword){
                    this.createQuery(this.currentKinds,  this.currentTags, keyword);
                },
                //availableTags: function (tags){
                //    tagBox = document.getElementById("tagbox");
                //    overflown = tagBox.scrollHeight > tagBox.clientHeight; 
                //    console.log("Height of tagbox:", tagBox.scrollHeight, tagBox.clientHeight);
                //},
                discoverCards: function (cards) {
                    filteredKinds = [];
                    tagWeights = {};
                    cards.forEach(c => {
                        c.tags.forEach( t=>
                            {
                                if (!this.availableTags.includes(t) && !this.currentTags.includes(t)){
                                    this.availableTags.push(t);
                                }
                                if (tagWeights[t]){
                                    tagWeights[t] +=1
                                }
                                else{
                                    tagWeights[t] = 1
                                }
                            }
                        )
                        c.kinds.forEach( k=>
                            {
                                if (!filteredKinds.includes(k.query)){
                                    filteredKinds.push(k.query);
                                }
                            }
                        )
                    })

                    //if (filteredKinds.length >0){
                    //    $('.discover-filter').each(function () {
                    //            var df = $(this);
                    //            if (filteredKinds.includes(df.attr('kind'))) {
                    //                df.addClass('active-filter');
                    //            }
                    //    });
                    //}

                    this.availableTags.sort((a, b) => (tagWeights[a] < tagWeights[b]) ? 1 : -1)

                },
                query: function (val) {
                    if (this.updateTimer)
                        clearTimeout(this.updateTimer);
                    if (this.stateTimer)
                        clearTimeout(this.stateTimer);

                    this.showKindTags = false;
                    this.availableTags =[];

                    const pushState = this.pushNewState;

                    let origKwd = val.toLowerCase();
                    var filteredCards = this.allCards;

                    var kindMatch = origKwd.match(/kind:(.+?)(\S+:|$|\s)/)
                    var tagMatch = origKwd.match(/tag:(.+?)(\S+:|$|\s)/)
                    var kwdMatch = origKwd.trim();

                    if (kindMatch) {
                        this.showKindTags = true;
                        kwdMatch = kwdMatch.replace(kindMatch[0], '').trim();
                        var kwd = kindMatch[1].trim();

                        if (kwd == 'new') {
                            filteredKinds.push("new");
                            var forgottenItems = getForgottenItems() || [];
                            filteredCards = selectItems(filteredCards.filter(
                                (c) => !forgottenItems.includes(c.url)
                            ));
                        }  else if (kwd != 'all') {
                            kindList = kwd.split(",").map(x=>x.trim());
                            filteredCards = selectItems(filteredCards.filter(
                                (c) => {
                                    const overlappingKinds = c.kinds.map(k => k.query).filter(kind => kindList.includes(kind));
                                    return overlappingKinds.length > 0;
                                }
                            ));
                        } else {
                            filteredCards = selectItems(filteredCards);
                        }

                    }

                    if (tagMatch) {
                        kwdMatch = kwdMatch.replace(tagMatch[0], '').trim();
                        var kwd = tagMatch[1];
                        if (kwd != '') {
                            tagList = kwd.split(",").map(x=>x.trim());
                            filteredCards = selectItems(filteredCards.filter(
                                (c) => {
                                    //Return cards that contain all selected tags
                                    for (const tag of tagList) {
                                        if (!c.tags.map(c=>c.toLowerCase()).includes(tag)){
                                            return false;
                                        }
                                      }
                                    return true;
                                }
                            ));
                        } else {
                            filteredCards = selectItems(filteredCards);
                        }
                    }

                    if (kwdMatch) {
                        //Search library doesn't support arrays, concatenate tags into new property
                        const searchCards = filteredCards.map((c, i) =>{
                            tags = c.tags.join(" ");
                            searchables =[c.author, c.title, tags, c.description];
                            return {
                                text:searchables.join(" "),
                                index: i
                            }
                        })

                        const results = fuzzysort.go(kwdMatch, searchCards, {
                            key:['text'], 
                            threshold: -15000
                        })
                        filteredCards = results.map(result => filteredCards[result.obj.index])
                    }

                    // set a history state only after user stopped changing
                    // filter query (if no input in 1 second)
                    this.stateTimer = setTimeout(() => {
                        if (pushState) {
                            var stateName = 'Search';
                            if (kwdMatch) {
                                stateName = `Search for "${kwdMatch}"`;
                            }
                            if (kindMatch) {
                                stateName += ` of kind "${kindMatch[1]}"`;
                            }

                            if (tagMatch) {
                                stateName += ` with tag "${tagMatch[1]}"`;
                            }

                            const modalUrl = new URLSearchParams(window.location.search).get('modal');
                            
                            history.pushState({
                                    query: origKwd, 
                                    modal: modalUrl,
                                }, stateName,
                                `?query=${origKwd}&modal=${modalUrl}`);

                            //this.modalContent = modalUrl;
                        }
                    }, this.internalFilter ? 0 : 500);

                    // if query has changed internally update immediately
                    if (this.internalFilter) {
                        this.discoverCards = filteredCards;
                        this.pushNewState = true;
                        this.internalFilter = false;
                    }
                    // only update data if the user stops typing for a bit
                    else {
                        this.updateTimer = setTimeout(() => {
                            this.discoverCards = filteredCards;
                            this.pushNewState = true;
                            this.internalFilter = false;

                            this.currentKinds = kindMatch? kindMatch[1].split(",").map(x =>x.trim()) : [] ;
                            this.currentTags = tagMatch? tagMatch[1].split(",").map(x =>x.trim()) : [];
                            this.keyword = kwdMatch;
                            //console.log("Update params from query", this.currentKinds, this.currentTags, this.keyword )
                        }, 100);
                    }
                },
                modalContent: function (url){
                    if (url){
                        const card = this.allCards.filter(c => c.url == url)[0];
                        this.selectedCard = card;
                        embedUrl = this.getEmbedUrl(url);
                        this.selectedCard.embedUrl = embedUrl;
                        $('#ModalCenter').modal();
                        queryUrl = `${removeURLParameter(window.location.search, "modal")}&modal=${url}`;

                        history.pushState({...history.state, modal : url}, "modal",
                        queryUrl);

                        //TODO: handle caption play for self hosted videos
                        setTimeout(function() { 
                            let video = document.querySelector('video');
                                    if (video){
                                    console.log("theres a video:", video)
                                    const track = video.textTracks[0] //you should choose you text track
                                    track.addEventListener('cuechange', onCueChange);
                                    caption = document.querySelector('.rma-caption');
                                    caption.innerHTML = 'Blah';
                                
                                    function onCueChange(event) {
                                    console.log(event.currentTarget.activeCues);
                                    if (event.currentTarget.activeCues.length > 0) {
                                        caption.style.display = 'inline-block'
                                        caption.innerHTML = event.currentTarget.activeCues[0].text;
                                        //console.log(event.currentTarget.activeCues[0].text);
                                    }
                                    else {
                                        caption.style.display = 'none';
                                        caption.innerHTML = "(empty)"
                                        //console.log("empty");
                                    }
                                    const cues = event.currentTarget.cues;
                                    for (let i = 0; i < cues.length; i++) {
                                        cues[i].line = 5;
                                        //cues[i].size = 0;
                                        cues[i].visibility = 'hidden';
                                    }
                                }
                            }
                         }, 1000);

                    }
                    else{
                        queryUrl = removeURLParameter(window.location.search, "modal")
                        history.pushState({...history.state, modal : null}, "modal close",
                        queryUrl);
                        this.selectedCard = null;
                    }
                },
                linkCheckIgnores: {
                    handler(ignoreLinksFrom){
                        this.linkHealthCheck(ignoreLinksFrom)
                      },
                      deep: true
                }
            },
            mounted: function () {
                setForgottenItems([])
                $('#discoverSpinner').css('display', 'none');
                $('#discoverGallery').css('visibility', 'visible');
                $("#ModalCenter").on("hidden.bs.modal", () => {
                    //Stop video playback
                    modalBody = document.getElementsByClassName("modal-body")[0];
                    var iframe = modalBody.querySelector( 'iframe');
                    var video = modalBody.querySelector( 'video' );
                    if ( iframe ) {
                        var iframeSrc = iframe.src;
                        iframe.src = iframeSrc;
                    }
                    if ( video ) {
                        video.pause();
                    }
                    this.modalContent = null;
                });
                const modalUrl = urlParams.get('modal');
                this.modalContent = modalUrl;

                const urlQuery = urlParams.get('query');
                this.query = urlQuery ? urlQuery : this.defaultQuery;
                let discoverCards = $(".discover-item");
                attachDiscoverItemHover(discoverCards);
                var forgottenItems = getForgottenItems();
                if (forgottenItems == undefined) {
                    forgetItems(discoverCards);
                }
                updateNewItems(discoverCards);
            },
            updated: function () {
                this.$nextTick(function () {
                    let discoverCards = $(".discover-item");
                    if (this.showKindTags)
                        hideCardKind(discoverCards);
                    else
                        showCardKind(discoverCards);
                    attachDiscoverItemHover(discoverCards);
                    updateNewItems(discoverCards);
                })
            }
        });
    });

    window.onpopstate = function (event) {
        app.pushNewState = false;
        app.query = event.state.query;
    };
</script>


{{ end }}