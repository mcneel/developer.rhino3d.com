# convert - dan@mcneel.com
# This python script converts the old Jekyll developer.rhino3d.com site to the Hugo static site engine.
# The Jekyll version of developer.rhino3d.com used git branches to determine which version of the site
# would be built and deployed.  The Hugo version generated by this script dispenses with version-specific
# branches and collapses everything in to the main branch. This script can be run progressively on the
# old 6, 7, and master branches (5 was ignored because the differences were somewhat significant) to generate
# the new site. After final conversion, this script is of limited value.

import subprocess
from subprocess import Popen, PIPE
import sys
import os
from os.path import expanduser
import re
from typing import DefaultDict, Dict
import toml
import os, tempfile
import shutil
from shutil import copyfile
import json

# general globals
debugging = True #TODO: Change this to True for the final run
baseURL = "https://developer.rhino3d.com"
old_root = os.path.abspath(os.path.join(expanduser("~"), "dev", "mcneel", "developer-rhino3d-com"))
old_content_authors_root_path = os.path.abspath(os.path.join(old_root, "_authors"))
old_content_guides_root_path = os.path.abspath(os.path.join(old_root, "_guide_topics"))
old_content_samples_root_path = os.path.abspath(os.path.join(old_root, "_samples"))
old_images_root_path = os.path.abspath(os.path.join(old_root, "images"))
old_content_videos_page_path = os.path.abspath(os.path.join(old_root, "videos.md"))
old_content_api_page_path = os.path.abspath(os.path.join(old_root, "api.md"))
old_files_root_path = os.path.abspath(os.path.join(old_root, "files"))

new_root = os.path.abspath(os.path.join(expanduser("~"), "dev", "mcneel", "developer.rhino3d.com"))
new_content_root_path = os.path.abspath(os.path.join(new_root, "content", "en"))
new_content_guides_root_path = os.path.abspath(os.path.join(new_content_root_path, "guides"))
new_content_samples_root_path = os.path.abspath(os.path.join(new_content_root_path, "samples"))
new_content_data_path = os.path.abspath(os.path.join(new_root, "data"))
new_images_root_path = os.path.abspath(os.path.join(new_root, "static", "images"))
new_files_root_path = os.path.abspath(os.path.join(new_root, "static", "files"))

# the list we need to populate
old_content_authors_paths = []
old_content_guides_paths = []
old_content_samples_paths = []

# this list needs to be populated manually and iteratively as we port 6, 7, master
# paths should be relative to the old root, like this: _posts/2015-06-04-welcome-to-jekyll.markdown
old_exclude_files = [
    "_posts/2015-06-04-welcome-to-jekyll.markdown",
    "_authors/dan_belcher.md"
]

# Frontmatter fields conversion ----------------------------------------------------------------------------------------

frontmatter_key_mapping = {
    "title": "title",
    "description": "description",
    "authors": "authors",
    "categories": "categories",
    "sdk": "sdk",
    "languages": "languages",
    "keywords": "keywords",
    "date": "date",
    "layout": "type",
    "order": "weight",
    "TODO": "TODO",
    "origin": "origin",
    "platforms": "platforms",
    "category_page": "category_page"
}

yaml_keys_to_ignore = ["author_contacts", "redirect_from", "permalink"]

# Authors conversion ---------------------------------------------------------------------------------------------------

# key = developer.rhino3d.com key
# value = rhino3d.com-theme key
authors_mapping = {
    "aj": "aj",
    "alain_cormier": "alain",
    "andrew_le_bihan": "andy",
    "andy_payne": "andy.payne",
    "arthur_van_der_harten": "arthur-van-der-harten",
    "brian_gillespie": "brian",
    "brian": "brian",
    "dale_fugier": "dale",
    "dale_lear": "dalelear",
    "dan_belcher": "dan",
    "dan_rigdon_bel": "dan",
    "david_leon": "david.leon",
    "david_rutten": "david",
    "giulio_piacentino": "giulio",
    "jess_maertterer": "jess-maertterer",
    "john_croudy": "john.croudy",
    "john_morse": "johnm",
    "luis_fraguada": "luis",
    "nathan_letwory": "nathan",
    "pascal_golay": "pascal",
    "rajaa_issa": "rajaa",
    "scott_davidson": "scottd",
    "skylar_tibbits": "skylar-tibbits",
    "steve_baer": "steve",
    "steven_janssen": "steven-janssen",
    "stylianos_dritsas": "stylianos-dritsas",
    "will_pearson": "will"
}

# Layout conversion ----------------------------------------------------------------------------------------------------
# The Jekyll site has 10 layout types. Jekyll makes no distinction between a "node" page and a "leaf" page, as Hugo does
# so we can map some Jekyll values like "guide-homepage" to the same type in Hugo, because Hugo can distinguish which
# layout to apply based upon the page's position and name (_index for nodes; index for leaves). In addition, since - in
# Hugo - we toggle the table-of-contents using a frontmatter value (toc), we can map those Jekyll layouts to the same 
# type in Hugo and toggle the toc during conversion.

# NOTE: At the moment, we are using layouts in the site/layouts folder (rather than the theme), but these layouts will
# likely be moved into the rhino3d.com-theme when possible/feasible.

# key = Jekyll developer.rhino3d.com key
# value = Hugo developer.rhino3d.com value
layout_mapping = {
    "authors-page": "authors",
    "admin": "admin",
    "fullwidth-page": "guides",
    "toc-page": "guides",
    "toc-guide-page": "guides",
    "guide-homepage": "guides",
    "bootstrap": "guides",
    "code-sample-cpp": "samples/cpp",
    "code-sample-rhinocommon": "samples/rhinocommon",
    "code-sample-python": "samples/python",
    "code-sample-rhinoscript": "samples/rhinoscript",
}

# Utility functions ----------------------------------------------------------------------------------------------------

# colors for terminal reporting
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


def print_warning_message(warning_message):
    warning_prefix = " warning: "
    print(bcolors.BOLD + bcolors.FAIL + warning_prefix.upper() + bcolors.ENDC + bcolors.FAIL + warning_message + bcolors.ENDC)


def print_error_message(error_message):
    error_prefix = " error: "
    print(bcolors.BOLD + bcolors.FAIL + error_prefix.upper() + bcolors.ENDC + bcolors.FAIL + error_message + bcolors.ENDC)


def print_ok_message(ok_message):
    ok_prefix = " ok: "
    print(bcolors.BOLD + bcolors.OKBLUE + ok_prefix.upper() + bcolors.ENDC + bcolors.OKBLUE + ok_message + bcolors.ENDC)


def copy_folder_tree_without_files(src, dst):
    src = os.path.abspath(src)

    src_prefix = len(src) + len(os.path.sep)

    if not os.path.exists(dst):
        os.makedirs(dst)
     
    for root, folders, files in os.walk(src):
        for dirname in folders:

            folder_path = os.path.join(dst, root[src_prefix:], dirname)
            
            if not os.path.exists(folder_path):
                os.mkdir(folder_path)


def get_markdown_files_list(path_to_crawl):
    path_list = []
    # Find all the markdown files in the old guides...
    for root, dirs, files in os.walk(path_to_crawl):
        for file in files:
            if file.endswith(".md"):
                path_to_old_file = os.path.abspath(os.path.join(root, file))
                path_list.append(path_to_old_file)

    # Remove exclusions (if any)...
    for file in old_exclude_files:
        exclude_path = os.path.abspath(os.path.join(old_root, file))
        if exclude_path in path_list:
            path_list.remove(exclude_path)
    
    return path_list


# If we move or change the location of a page while porting the site, we need to keep a list
def log_redirect_url(fromURL, toURL):
    if fromURL != toURL:
        global baseURL
        script_folder = os.path.dirname(os.path.abspath(__file__))
        redirect_log_path = os.path.abspath(os.path.join(script_folder, "redirect_log.json"))
        redirectURL = "[\"" + baseURL + fromURL + "\", " + "\"" + baseURL + toURL + "\"],\n"
        if os.path.exists(redirect_log_path):
            redirect_log_file = open(redirect_log_path, "r")
            existing_redirects = redirect_log_file.read()
            redirect_log_file.close()
            if not redirectURL in existing_redirects:
                redirect_log_file = open(redirect_log_path, "a")
                redirect_log_file.write(redirectURL)
                redirect_log_file.close()
        else:
            redirect_log_file = open(redirect_log_path, "a")
            redirect_log_file.write(redirectURL)
            redirect_log_file.close()


# YAML to TOML frontmatter conversion ----------------------------------------------------------------------------------

# The python frontmatter library dumps an extra comma at the end of each list entry, so remove it
def strip_extra_comma(toml_frontmatter_old):
    toml_frontmatter_new = toml_frontmatter_old.replace('\",]', '\" ]')
    return toml_frontmatter_new


def remove_toml_separators(toml_frontmatter_old):
    toml_without_separators = toml_frontmatter_old
    if toml_without_separators.startswith('+++\n'):
        toml_without_separators = toml_frontmatter_old.split('+++\n')[1].strip()
    if toml_without_separators.endswith('\n+++\n'):
        toml_without_separators = toml.frotnmatter_old.split('\n+++')[0].strip()
    
    return toml_without_separators


def add_toml_separators(toml_frontmatter_old):
    toml_with_separators = toml_frontmatter_old
    if not toml_with_separators.startswith('+++\n'):
        toml_with_separators = '+++\n' + toml_with_separators
    if not toml_with_separators.endswith('\n+++\n'):
        toml_with_separators = toml_with_separators + '\n+++\n'
    
    return toml_with_separators


# This is where we replace old key titles with new key titles (not value content)
# We also keep track of the mappings between the yaml keys and the toml keys to make sure some mapping has been
# properly established.  Some keys get ignored on purpose.
def rename_frontmatter_keys(toml_frontmatter_old):
    toml_without_separators = remove_toml_separators(toml_frontmatter_old)
    toml_dictionary = {}
    toml_dictionary = toml.loads(toml_without_separators)

    # audit: record each of the old frontmatter keys in the mapping dictionary to make sure we're not missing any
    global frontmatter_key_mapping
    global yaml_keys_to_ignore
    for key in toml_dictionary:
        if not key in yaml_keys_to_ignore:
            if not key in frontmatter_key_mapping:
                frontmatter_key_mapping[key] = "[missing]"

    # title (string) -> title (string)
    # description (string) -> description (string)
    # authors [string] -> authors [string]
    # categories [string] -> categories [string]
    # sdk [string] -> sdk [string]
    # languages [string] -> languages [string]
    # keywords [string] -> keywords [string] (not yet used on rhino3d.com-theme sites)

    # date (date in frontmatter is not used, but there is a last-modified) - but we'll set that later

    # layout -> type
    if "layout" in toml_dictionary:
        toml_dictionary["type"] = toml_dictionary.pop("layout")

    # order -> weight (int)
    if "order" in toml_dictionary:
        toml_dictionary["weight"] = toml_dictionary.pop("order")
    
    # [admin]
    # todo (string) -> todo (string)
    # origin (string) -> origin (string)
    
    # move todo and origin into the [admin] namespace (dict) and add some missing keys for picky sisters and state
    toml_dictionary["admin"] = {}
    if "TODO" in toml_dictionary or "origin" in toml_dictionary:
        if "TODO" in toml_dictionary:
            toml_dictionary["admin"]["TODO"] = toml_dictionary["TODO"]
            toml_dictionary.pop('TODO', None)
        else:
            toml_dictionary["admin"]["TODO"] = ""
        if "origin" in toml_dictionary:
            if toml_dictionary["origin"] == "unset" or toml_dictionary["origin"] == " ":
                toml_dictionary["admin"]["origin"] = ""
            else:
                toml_dictionary["admin"]["origin"] = toml_dictionary["origin"]
            toml_dictionary.pop('origin', None)
        else:
            toml_dictionary["admin"]["origin"] = ""
    toml_dictionary["admin"]["picky_sisters"] = ""
    toml_dictionary["admin"]["state"] = ""
    
    # [included_in]
    # platforms [string] -> platforms [string]
    # move platforms into [included_in] namespace (dict) and add the missing key "since"
    toml_dictionary["included_in"] = {}
    if "platforms" in toml_dictionary:
        toml_dictionary["included_in"]["platforms"] = toml_dictionary["platforms"]
        toml_dictionary.pop('platforms', None)
    else:
        toml_dictionary["included_in"]["platforms"] = []
    since = 0
    toml_dictionary["included_in"]["since"] = since
    
    # [page_options] - this maps pages that have a toc style layout (in jekyll) to those that have toc and bylines set
    if toml_dictionary["type"]:
        if toml_dictionary["type"].startswith('toc-'):
            toml_dictionary["page_options"] = {}
            byline = False
            toc = False
            if toml_dictionary["type"] == "toc-guide-page":
                byline = True
                toc = True
            else:
                toc = True
            toml_dictionary["page_options"]["byline"] = byline
            toml_dictionary["page_options"]["toc"] = toc
            if toc:
                toml_dictionary["page_options"]["toc_type"] = "single"

    # Remove ignored yaml keys (don't port them across to the toml)
    toml_dictionary_trimmed = {}
    for key, value in toml_dictionary.items():
        if not key in yaml_keys_to_ignore:
            toml_dictionary_trimmed[key] = value
    toml_dictionary = toml_dictionary_trimmed

    # Finish up...
    toml_frontmatter_new = toml.dumps(toml_dictionary)
    toml_frontmatter_new = add_toml_separators(toml_frontmatter_new)
    toml_frontmatter_new = strip_extra_comma(toml_frontmatter_new)
    
    return toml_frontmatter_new


# This is where we replace old values with new values
def rename_frontmatter_values(toml_frontmatter_old):
    toml_without_separators = remove_toml_separators(toml_frontmatter_old)

    toml_dictionary = {}
    toml_dictionary = toml.loads(toml_without_separators)

    # Authors
    if "authors" in toml_dictionary:
        if not toml_dictionary["authors"] == "unset" and not toml_dictionary["authors"] == '':
            for key, value in toml_dictionary.items():
                if key == "authors":
                    new_authors = []
                    for author in toml_dictionary["authors"]:
                        new_authors.append(authors_mapping[author])
                    toml_dictionary["authors"] = new_authors
                else:
                    break

    # Layouts/Types
    if "type" in toml_dictionary:
        if not toml_dictionary["type"] == "unset" and not toml_dictionary["type"] == '':
            old_type = toml_dictionary["type"]
            new_type = layout_mapping[old_type]
            toml_dictionary["type"] = new_type
            # special case homepage
            if toml_dictionary["title"] == "Rhino and Grasshopper Developer Documentation":
                toml_dictionary["type"] = "home"

    toml_frontmatter_new = toml.dumps(toml_dictionary)
    toml_frontmatter_new = add_toml_separators(toml_frontmatter_new)
    toml_frontmatter_new = strip_extra_comma(toml_frontmatter_new)

    return toml_frontmatter_new


def add_override_last_modified(toml_frontmatter_old, override_last_modified):
    toml_without_separators = remove_toml_separators(toml_frontmatter_old)

    toml_dictionary = {}
    toml_dictionary = toml.loads(toml_without_separators)

    toml_dictionary["override_last_modified"] = override_last_modified

    toml_frontmatter_new = toml.dumps(toml_dictionary)
    toml_frontmatter_new = add_toml_separators(toml_frontmatter_new)
    toml_frontmatter_new = strip_extra_comma(toml_frontmatter_new)

    return toml_frontmatter_new
    

def convert_frontmatter(old_frontmatter, override_last_modified):
    #split by newlines
    yaml_items = old_frontmatter.split('\n')

    toml_items = []
    for item in yaml_items:
        should_append_item = True
        # delimiters
        if item.startswith('---'):
            item = re.sub('---', '+++', item)
        else:
            # title: string (standard key/value string-to-string)
            if not '[' in item:
                yaml_value = ''
                if item:
                    yaml_value = item.split(":", 1)[1].strip()

                if yaml_value.isnumeric():
                    item = re.sub(r'([^:]*):\s*([^\[]*)', r'\1 = \2', item)
                else:
                    key_title = item.split(':', 1)[0]

                    if not key_title: # final line
                        item = ""
                    else:
                        item_split = item.split(':', 1)
                        if len(item_split) == 1:
                            should_append_item = False
                        elif len(item_split) == 2:
                            formatted_value = item_split[1].strip()
                            if formatted_value.startswith("'") or formatted_value.startswith("\""):
                                formatted_value = formatted_value[1:]
                            if formatted_value.endswith("'") or formatted_value.endswith("\""):
                                formatted_value = formatted_value[:-1]
                            
                            if formatted_value:
                                if formatted_value != "# empty":
                                    item = key_title + " = " + "\"" + formatted_value + "\""
                                else:
                                    should_append_item = False
                            else:
                                should_append_item = False

                        else:
                            print_error_message("bad formatting in original yaml entry.")
                            sys.exit(1)

            else:
                # lists
                key_title = item.split(':', 1)[0]

                old_list_values = item.split('[')[1].split(']')[0].split(",")
                if not old_list_values[0]:
                    item = key_title + ' = []'
                else:
                    new_list_values = []
                    for value in old_list_values:
                        value = value.replace('\'', '\"').strip()
                        if value != '"':
                            new_list_values.append(value)

                    # Handle mal-formed yaml values
                    new_list_values_sanitized = []
                    for value in new_list_values:
                        if not value.startswith('"'):
                            value = '"' + value
                        if not value.endswith('"'):
                            value = value + '"'
                        new_list_values_sanitized.append(value)
                        
                    new_list_values_string = ', '.join(new_list_values_sanitized)
                    if new_list_values_string.endswith(','):
                        new_list_values_string = new_list_values_string[:-1]

                    item = key_title + ' = [ ' + new_list_values_string + ' ]'
        
        if should_append_item:
            toml_items.append(item)
    
    # sort alphabetically...
    sorted_items = toml_items[1:-2]
    sorted_items.sort()
    sorted_toml_items = []
    sorted_toml_items.append(toml_items[0])
    sorted_toml_items = sorted_toml_items + sorted_items + toml_items[-2:]
    
    # flatten it all back into a single string
    new_frontmatter = "\n".join(sorted_toml_items)

    # Churn through the toml frontmatter, renaming first the field titles, then the contents, if necessary...
    new_frontmatter = rename_frontmatter_keys(new_frontmatter)
    new_frontmatter = rename_frontmatter_values(new_frontmatter)

    # Add the override_last_modified if set
    if override_last_modified:
        new_frontmatter = add_override_last_modified(new_frontmatter, override_last_modified)

    return new_frontmatter


# the hugo yaml toTOML parser is more robust, but slower and it does not do linting along the way. This should be used
# for comparison purposes with our own, customer parser above, as well as to highlight potential bugs with our
# yaml-to-toml converter above
def hugo_convert_frontmatter(old_frontmatter):
    new_frontmatter = ''

    # Write the old frontmatter to a temp folder on disk
    temp_root = os.path.abspath(tempfile.gettempdir())
    temp_dummy_hugo_root = os.path.abspath(os.path.join(temp_root, "temp_dummy_hugo_root"))
    temp_dummy_hugo_content = os.path.abspath(os.path.join(temp_dummy_hugo_root, "content"))

    if not os.path.exists(temp_dummy_hugo_root):
        os.makedirs(temp_dummy_hugo_root)

    # Copy hugo over
    script_folder = os.path.dirname(os.path.abspath(__file__))
    path_to_hugo_orig = os.path.abspath(os.path.join(script_folder, "..", "hugo"))
    path_to_hugo_new = os.path.abspath(os.path.join(temp_dummy_hugo_root, "hugo"))
    if not os.path.exists(path_to_hugo_new):
        if not os.path.exists(path_to_hugo_orig):
            print_error_message("hugo not found, please make sure it's in the root folder before running...it's needed to convert the yaml to toml")
            sys.exit(1)
        copyfile(path_to_hugo_orig, path_to_hugo_new)

    # Create the dummy config file to appease hugo
    temp_dummy_config_path = os.path.abspath(os.path.join(temp_dummy_hugo_root, "config", "_default"))
    if not os.path.exists(temp_dummy_config_path):
        os.makedirs(temp_dummy_config_path)
        temp_dummy_config_file_path = os.path.abspath(os.path.join(temp_dummy_config_path, "config.toml"))
        dummy_config_file = open(temp_dummy_config_file_path, "w")
        dummy_config_file.write("")
        dummy_config_file.close()

    # Create a spot for the input - deleting the old if it existss
    if os.path.exists(temp_dummy_hugo_content):
        shutil.rmtree(temp_dummy_hugo_content)
    
    os.makedirs(temp_dummy_hugo_content)

    # Delete old output if it exists and make a spot for the new
    temp_dummy_toml_output_root = os.path.abspath(os.path.join(temp_dummy_hugo_root, "toTOML"))
    if os.path.exists(temp_dummy_toml_output_root):
        shutil.rmtree(temp_dummy_toml_output_root)
    os.makedirs(temp_dummy_toml_output_root)
    
    temp_input_file_path = os.path.abspath(os.path.join(temp_dummy_hugo_content, "temp_frontmatter.md"))
    temp_input_file = open(temp_input_file_path, "w")
    temp_input_file.write(old_frontmatter)
    temp_input_file.close()

    os.chdir(temp_dummy_hugo_root)
    # hugo convert toTOML --verbose --log -s . -o toTOML
    hugo_totoml_process = subprocess.Popen(['hugo', 'convert', 'toTOML', '--verbose', '--log', '-s', '.', '-o', 'toTOML'], stdin=PIPE, stdout=PIPE, stderr=PIPE)
    hugo_totoml, err = hugo_totoml_process.communicate()

    temp_output_file_path = os.path.abspath(os.path.join(temp_dummy_toml_output_root, "content", "temp_frontmatter.md"))
    temp_output_file = open(temp_output_file_path, "r")

    new_frontmatter = temp_output_file.read()
    temp_output_file.close()

    # Churn through the toml frontmatter, renaming first the field titles, then the contents, if necessary...
    new_frontmatter = rename_frontmatter_keys(new_frontmatter)
    new_frontmatter = rename_frontmatter_values(new_frontmatter)

    return new_frontmatter


# Markdown content conversion handlers ---------------------------------------------------------------------------------
def convert_markdown_content(old_content):
    new_content = ""

    # -----------------------------------------------------------------------------------------------------------
    # Useful VSCode search: \x7B{2}[^\x3C].*?[^\x3E]\x7D{2} in *.md  ...this is {{ stuff }} but not {{< stuff >}}
    # REGEX template: new_content = re.sub(r'pattern', r'replace', new_content, flags=re.MULTILINE | re.DOTALL)
    # -----------------------------------------------------------------------------------------------------------

    # BaseURL links - {{ site.baseurl }}
    new_content = re.sub(r'\x7B{2}(\s{0,4})site.baseurl(\s{0,4})\x7D{2}', r'', old_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x7B{2}(\s{0,4})site.basurl(\s{0,4})\x7D{2}', r'', new_content, flags=re.MULTILINE | re.DOTALL)

    # Branch specific links - {{ site.git_branch ...}}
    new_content = re.sub(r'developer-rhino3d-com/blob/\x7B{2}(\s{0,4})site.git_branch(\s{0,4})\|(\s{0,4})default:(.{0,9})(\s{0,4})\x7D{2}', r'developer-rhino3d-com/blob/main', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'rhino-developer-samples/blob/\x7B{2}(\s{0,4})site.git_branch(\s{0,4})\|(\s{0,4})default:(.{0,9})(\s{0,4})\x7D{2}', r'rhino-developer-samples/blob/master', new_content, flags=re.MULTILINE | re.DOTALL)

    # Author links
    for key, value in authors_mapping.items():
        old_author_link = "(/authors/" + key + ")"
        new_author_link = "(/authors/" + value + ")"
        new_content = new_content.replace(old_author_link, new_author_link)

    # new_content = re.sub(r'(/authors/)(.{0,30})_(.{0,30})', r'\1\2-\3', new_content) # <--old regex
    new_content = re.sub(r'Dan Belcher', r'Dan Rigdon-Bel', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'dan-belcher', r'dan', new_content, flags=re.MULTILINE | re.DOTALL)

    # css formatting suffixes: https://digitaldrummerj.me/styling-jekyll-markdown/
    new_content = re.sub(r'\x7B: rules="groups"\x7D', r'', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x7C\x3D{5}\s\x7C\s\x7B\x3A.*?\x7D', r'', new_content, flags=re.MULTILINE | re.DOTALL)

    # homepage special cases
    new_content = re.sub(r'<div align="center">.{0,10}(<p>Welcome to the Rhino . version of this site).+?(<p>Rhino developer tools are royalty free and include support.</p>.{0,10}</div>)', r'{{< center >}}\n\nRhino developer tools are royalty free and include support.\n\n{{< /center >}}', new_content, flags=re.MULTILINE | re.DOTALL)

    # Horizontal rule formatters (---)
    new_content = re.sub(r'\n---\n\n', r'\n', new_content, flags=re.MULTILINE | re.DOTALL)

    # Header level inconsistencies
    new_content = re.sub(r'#### Related Topics', r'## Related Topics', new_content, flags=re.MULTILINE | re.DOTALL)

    # youtube embeds
    new_content = re.sub(r'{%\s{0,2}include\s{0,2}youtube_player.html\s{0,2}id=.(.{0,11}).\s{0,2}%}', r'{{< youtube \1 >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'<div\s{0,2}class="embed-responsive\s{0,2}embed-responsive-16by9">\s{0,6}<iframe\s}{0,2}.{0,250}\s{0,2}src=.https://www.youtube.com/embed/(.{0,11}).\s{0,2}.{0,250}</iframe>\s{0,6}</div>', r'{{< youtube \1 >}}', new_content, flags=re.MULTILINE | re.DOTALL)

    # vimeo includes
    new_content = re.sub(r'<div\s{0,2}class="embed-responsive\s{0,2}embed-responsive-16by9">\s{0,6}<iframe\s}{0,2}class=.embed-responsive-item.\s{0,2}src=.https://player.vimeo.com/video/(.{0,9}).></iframe>\s{0,6}</div>', r'{{< vimeo \1 >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x7B\x25\s{0,1}include\svimeo_player.html\sid\x3D\x22(.*?)\x22\s{0,1}\x25\x7D', r'{{< vimeo \1 >}}', new_content, flags=re.MULTILINE | re.DOTALL)

    # download links
    new_content = re.sub(r'<a .*?href=\"([^\"]*)\"><span\s{0,2}class="glyphicon glyphicon-download"></span>(.{0,500})</a>', r'[{{< awesome "fas fa-download">}} \2](\1)', new_content) # this one really needs to not be multiline or it messes up some of the top-level pages

    # multi-column layouts
    # <!--column--> style layouts
    regexp = re.compile(r'<!--column-->')
    if regexp.search(new_content):
        new_content = '{{< row >}}\n{{< column >}}\n' + new_content + '\n{{< /column >}}\n{{< /row >}}\n'
        new_content = re.sub(r'<!--column-->', r'{{< /column >}}\n{{< column >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    
    # multi-column layouts using html: 
    # columns first because they are inner
    new_content = re.sub(r'(?s)(<div class="col-md-7 col-sm-12 col-sm-12" markdown="1">)(.*?)(\n</div>)', r'{{< column >}}\2\n{{< /column >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(?s)(<div\s{0,2}class="col-md-4"\s{0,2}markdown="1">)(.*?)(\n</div>)', r'{{< column >}}\2\n{{< /column >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    # rows next because they are outer
    new_content = re.sub(r'(?s)(<div class="row-fluid">)(.*?)(\n</div>)', r'{{< row >}}\2\n{{< /row >}}', new_content, flags=re.MULTILINE | re.DOTALL)

    # Liquid templating that iterates a list - usually a ul -  will be surrounded by: <div class="trigger">  ... </div>
    # we use the following shortcode: {{< dev-topic-list "guides" "RhinoCommon" "Rendering" "weight" >}}
    # A couple of the pages have hardcoded <li> items in them - esp the RhinoCommon Advanced one - account for these...
    new_content = re.sub(r'(<div class="trigger">\n\s{0,4}\x7B% assign guides = site.guide_topics \| sort:"order" %\x7Dn\s{0,4}<ul>\n\s{0,4}<li><a href="(.{0,30})">)(.{0,30})</a></li>\n\s{0,4}<li><a href="(.{0,60})">(.{0,50})</a></li>', r'- [\3](\2)\n- [\5](\4)\n\n\1', new_content, flags=re.MULTILINE | re.DOTALL)
    # The RhinoPython sample source doesn't contain a categories section, so we need to parse these two special-cases in this order to get the sample index correct
    new_content = re.sub(r'<div class="trigger".*?for.*?in samples[ %]+.*?sdk contains \'RhinoCommon\'.*?categories contains \'(.*?)\'.*?<\/div>', r'{{< dev-topic-list "samples" "RhinoCommon" "\1" "weight" >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'<div class="trigger".*?for.*?in samples[ %]+.*?sdk contains \'RhinoPython\'.*?<\/div>', r'{{< dev-topic-list "samples" "RhinoPython" "Adding Objects" "weight" >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    # ...then replace the rest with with the shortcode, the general case:
    new_content = re.sub(r'<div class="trigger".*?for.*?in (\w+?)[ %]+.*?sdk contains \'(.*?)\'.*?categories contains \'(.*?)\'.*?<\/div>', r'{{< dev-topic-list "\1" "\2" "\3" "weight" >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    # Then handle the {% assign guides } cases in /guides/yak (which don't use the triggers)
    new_content = re.sub(r'\x7B\x25\sassign guides = site.guide_topics\s\x7C\swhere:\x22sdk\x22,\x22Yak\x22\s\x7C\swhere:\x22categories\x22,\x22(.*?)\x22\s\x7C\ssort.*?\x25\x7D', r'{{< dev-topic-list "guides" "Yak" "\1" "weight" >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x3Cul\x3E\s\x7B\x25\sfor guide in guides \x25\x7D\s\s\s\x3Cli\x3E\x3Ca href=\x22\x7B{2} guide.url \x7C prepend:\ssite.baseurl \x7D{2}\x22\x3E\x7B{2} guide.title \x7D{2}\x3C/a\x3E\x3C/li\x3E\s\x7B\x25 endfor \x25\x7D.{0,150}\x3C/ul\x3E', r'', new_content, flags=re.MULTILINE | re.DOTALL)

    # Remove hardcoded platform images
    new_content = re.sub(r'\s<img src="/images/.*?-logo-small.png" alt=".*?" class="guide_icon">', r'', new_content, flags=re.MULTILINE | re.DOTALL)

    # Remove hardcoded anchor tags
    new_content = re.sub(r'\x7B:\s{0,2}#.{0,20}\s{0,2}\x7D', r'', new_content, flags=re.MULTILINE | re.DOTALL)

    # Code blocks (samples) with tabbed content
    if ("```cs" in new_content) and ("```vbnet" in new_content) and ("```python" in new_content):
        new_content = re.sub(r'(```cs\s.+?```).+?{:\s#cs\s.tab-pane .fade .in .active\s{0,1}}', r'<div class="codetab-content" id="cs">\n\n\1\n\n</div>', new_content, flags=re.MULTILINE | re.DOTALL)
        new_content = re.sub(r'(```vbnet\s.+?```).+?{:\s#vb .tab-pane .fade .in}', r'<div class="codetab-content" id="vb">\n\n\1\n\n</div>', new_content, flags=re.MULTILINE | re.DOTALL)
        new_content = re.sub(r'(```python\s.+?```).+?{:\s#py .tab-pane .fade .in}', r'<div class="codetab-content" id="py">\n\n\1\n\n</div>', new_content, flags=re.MULTILINE | re.DOTALL)

    # Footnotes - from headers to sections
    new_content = re.sub(r'#{1,3}\sFootnotes:{0,1}', r'**Footnotes**', new_content, flags=re.MULTILINE | re.DOTALL)

    # Essential Mathematics Special cases
    new_content = re.sub(r'# Essential Mathematics for Computational Design', r'', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(..< column >..\s*)(.*?.Essential Mathematics for Computational Design.*?..< /column >..).*?(\!\[(/images/math-logo.svg)\]).*?</div>', r'\1![\4 alt >](\4)\n\n\2', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'<div class=.note..markdown=.1.>(.*?)</div>', r'{{< call-out note "Note" >}}\n\1\n{{< /call-out >}}', new_content, flags=re.MULTILINE | re.DOTALL)

    # Mathjax
    new_content = re.sub(r'\\(\$\$)', r'\1', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\$\$(.*?)\$\$', r'{{< mathjax >}}$$\1$${{< /mathjax >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'..< mathjax >..(.._save_..)..< /mathjax >..', r'\1', new_content, flags=re.MULTILINE | re.DOTALL) #special case of non-Mathjax $$ use

    # Image alignment
    new_content = re.sub(r'\x21\x5B(.{0,100})\x5D\x28(.{0,100})\x29\x7B\x3A\s\x2Efloat-img-left\swidth\x3D\x22(\d{0,5})\x22\x7D', r'{{< image url="\2" alt="\1" class="float_left" width="\3" >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x21\x5B(.{0,100})\x5D\x28(.{0,100})\x29\x7B\x3A\s\x2Efloat-img-right\swidth\x3D\x22(\d{0,5})\x22\x7D', r'{{< image url="\2" alt="\1" class="float_right" width="\3" >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x21\x5B(.{0,100})\x5D\x28(.{0,100})\x29\x7B\x3A\s{1,2}\x2Efloat-img-right\s{1,2}\x7D', r'{{< image url="\2" alt="\1" class="float_right" >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'&nbsp;\x7B:\s.clear-img\x7D', r'{{< div class="clear_both" />}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x7B:\s.clear-img\x7D', r'{{< div class="clear_both" />}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x7B\x3A\s{0,2}style\x3D\x22clear\x3Aboth\x3B\x22\x7D', r'{{< div class="clear_both" />}}', new_content, flags=re.MULTILINE | re.DOTALL)  #{:style="clear:both;"}
    new_content = re.sub(r'\x21\x5B(.{0,100})\x5D\x28(.{0,100})\x29\x7B\x3A\s\x2Eimg-center\s{1,2}width\x3D\x22(\S{1,5})\x22\x7D', r'{{< image url="\2" alt="\1" class="image_center" width="\3" >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x21\x5B(.{0,100})\x5D\x28(.{0,100})\x29\x7B\x3A\s{1,2}\x2Eimg-center\s\x7D', r'{{< image url="\2" alt="\1" class="image_center" >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x3Cimg\ssrc\x3D\x22(.{1,60})\x22\x3E\x7B\x3A\s\x2Eimg-center\s{1,2}width\x3D\x22(\S{0,5})\x22\x7D', r'{{< image url="\1" alt="\1" class="image_center" width="\2" >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x21\x5B(.{0,100})\x5D\x28(.{0,100})\x29\x7B\x3A\s{1,2}width\x3D\x22(\S{1,5})\x22\x7D', r'{{< image url="\2" alt="\1" width="\3" >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x21\x5B(.{0,100})\x5D\x28(.{0,100})\x29\x7B\x3A\s{1,2}\x2Efloat-img-center\swidth\x3D\x22(\S{1,5})\x22\x7D', r'{{< image url="\2" alt="\1" width="\3px" >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x21\x5B(.{0,100})\x5D\x28(.{0,100})\x29\x7B\x3Astyle=\x22float:\sright;.*?\x22\x7D', r'{{< image url="\2" alt="\1" class="float_right" >}}', new_content, flags=re.MULTILINE | re.DOTALL)

    # Remove remaining redundant Titles
    new_content = re.sub(r'#\sAuthors.*?(Thanks to all who have)', r'\1', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'# Compute Guides', r'', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'# Rhino.Python Primer 101  ', r'', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'# RhinoScript Primer 101', r'', new_content, flags=re.MULTILINE | re.DOTALL)

    # Fix heading levels
    new_content = re.sub(r'# Dynamic Layout', r'## Dynamic Layout', new_content, flags=re.MULTILINE | re.DOTALL)
    # The # Next Steps ones are hard to fix because they are at the start of a line so we should fix these after porting

    # {: .multiline} - this is for tables of linenumber explanations
    new_content = re.sub(r'\x3Ctable\x3E(.*?)\x3C\x2Ftable\x3E\s\x7B\x3A\s{1,2}\x2Emultiline\s{0,1}\x7D', r'<table class="multiline">\1</table>', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x3Ctable width\x3D\x22100%\x22\x3E(.*?)\x3C\x2Ftable\x3E\s\x7B\x3A\s{1,2}\x2Emultiline-middle\s{0,1}\x7D', r'<table class="multiline-middle" width="100%">\1</table>', new_content, flags=re.MULTILINE | re.DOTALL)

    # {:.language-cs}
    new_content = re.sub(r'(\x60)\x7B\x3A\x2Elanguage-cs\x7D\s', r'\1', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(\x60)\x7B\x3A\x2Elanguage-cs\x7D', r'\1', new_content, flags=re.MULTILINE | re.DOTALL)

    # {: .line-numbers}
    # First, remove a bad vb code-block that causes problems below
    new_content = re.sub(r'(\x60\x60\x60vb)\s\s', r'\1\n', new_content, flags=re.MULTILINE | re.DOTALL)
    # Second, replace the {: .line-numbers } with {{< /div >}} closing shortcode to maintain length of overall string
    new_content = re.sub(r'\x7B\x3A\s{0,1}\x2Eline-numbers\s{0,1}\x7D', r'{{< /div >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    if '{{< /div >}}' in new_content:
        lines = new_content.split("\n")
        ranges_list = []
        for i in range(len(lines)):
            if lines[i].startswith('```'):
                if (len(lines[i+1]) > 0) and not ('{{< /div >}}' in lines[i+1]): # if it's the start of a code-block
                    # look ahead to the closing code-block backticks
                    for j in range(i+1, len(lines)):
                        if lines[j].startswith('```') and lines[j].endswith('```'):
                            # see if if the following line contains the line-numbers {{< /div >}} tag
                            if '{{< /div >}}' in lines[j+1]:
                                range_start = i
                                range_end = j+1
                                ranges_list.append(range(range_start, range_end))
                            else:
                                break # it's not a line-numbers code-block, just a regular one.
        # now we have our ranges list of code-blocks with line-numbers
        new_lines = []
        for i in range(len(lines)):
            is_start_of_range = False
            # Check to see if the index is equal to any of the start ranges
            for range_to_check in ranges_list:
                if i == range_to_check[0]:
                    is_start_of_range = True
            
            if is_start_of_range:
                new_line = '{{< div class=\"line-numbers\" >}}' + lines[i]
                new_lines.append(new_line)
            else:
                new_lines.append(lines[i])

        # Flatten the string back into new_content
        new_content = '\n'.join(new_lines)
    
        # Finally split the top-level div back into two separate lines at the start of the code-block
        new_content = re.sub(r'(\x7B\x7B\x3C\sdiv class=.line-numbers.\s\x3E\x7D\x7D)(\x60\x60\x60)', r'\1\n\2', new_content, flags=re.MULTILINE | re.DOTALL)

    # {:class=“table table-bordered”} and re-align table
    new_content = re.sub(r'\x7B\x3Aclass=.table\stable-bordered.\x7D', r'', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(Procedure for deletion\s\x7C\s\x7C)(-*)\x7C(-*)\x7C', r'\1:\2|:\3|', new_content, flags=re.MULTILINE | re.DOTALL)

    # {: .multiline} removal
    new_content = re.sub(r'\x7B\x3A\s\x2Emultiline\x7D', r'', new_content, flags=re.MULTILINE | re.DOTALL)

    # Weird edge case where tables were used inappropriately
    new_content = re.sub(r'(\x7C\sCurve\sPlane\sIntersection\s\x7C).*?\x7B\x3A\s\x2Eguide_fullwidth\x7D', r'* Curve Plane Intersection\n* Project Curve\n* Pull Curve\n* Split with Brep\n* Shatter\n* Split with Breps\n* Trim with Brep\n* Trim with Breps\n* Area\n* Area Moments\n* Volume\n* Volume Moments\n* Brep Closest Point\n* Mesh Plane Intersection\n* Brep Line Intersection\n* Brep Brep Intersection\n* Brep Plane Intersection\n* Curve Curve Intersection\n* Curve Curves Intersection\n* Point in Brep\n* Point in Breps\n* Curve Self-Intersection \n* Contour\n* Dash Pattern\n* Divide Curve\n* Boundary Surface', new_content, flags=re.MULTILINE | re.DOTALL)

    # Remove obsolete documentation
    new_content = re.sub(r'\x23{3}\sInline\sAttributes.*?(\x23{3}\s)', r'\1', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x23{3}\sBlock\sAttributes.*?(\x23{3}\s)', r'\1', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x23{3}\sHTML\sElements.*?(\x23{3}\s)', r'\1', new_content, flags=re.MULTILINE | re.DOTALL)

    # Remove obsolete {:start="8"} tags
    new_content = re.sub(r'\x7B\x3Astart=\x22\d\x22\x7D', r'', new_content, flags=re.MULTILINE | re.DOTALL)

    # tab-pane code-block samples
    # First, handle the <ul class="nav nav-pills">
    new_content = re.sub(r'\x3Cul\sclass=\x22nav\snav-pills\x22\x3E\s*?\x3Cli\sclass=\x22active\x22\x3E\x3Ca\shref=\x22\x23(.*?)\x22\sdata-toggle=\x22pill\x22\x3E(.*?)\x3C\x2Fa\x3E\x3C\x2Fli\x3E\s*?\x3Cli\x3E\x3Ca\shref=\x22\x23(.*?)\x22\sdata-toggle=\x22pill\x22\x3E(.*?)\x3C\x2Fa\x3E\x3C\x2Fli\x3E\s\x3C\x2Ful\x3E', r'<div class="codetab">\n  <button class="tablinks" onclick="openCodeTab(event, \'\1\')" id="defaultOpen">\2</button>\n  <button class="tablinks" onclick="openCodeTab(event, \'\3\')">\4</button>\n</div>', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r"\x28event,\s\x5C\x27(.*?)\x5C\x27\x29", r"(event, '\1')", new_content, flags=re.MULTILINE | re.DOTALL) # fix escaped single quotes
    # Second, iterate through these new code-tabs and make the ids unique
    lines = new_content.split("\n")
    # Find all the lines with tablinks...
    tablinks_list = []
    for i in range(len(lines)):
        if '<button class="tablinks' in lines[i]:
            tablinks_list.append(i)
    # ...go through and label each of the lines and add the counter
    if len(tablinks_list) > 0:
        if len(tablinks_list) % 2 == 0: # only process those with two code tabs (we may need to special-case three)
            new_lines = []
            counter = 0
            for i in range(len(lines)):
                if i in tablinks_list:
                    l1 = lines[i]
                    l2 = lines[i+1]
                    if counter > 0:
                        l1_new = re.sub(r'tablinks', r'tablinks' + str(counter), l1)
                        l1_new = re.sub(r'defaultOpen', r'defaultOpen' + str(counter), l1_new)
                        l2_new = re.sub(r'tablinks', r'tablinks' + str(counter), l2)
                        l2_new = re.sub(r'defaultOpen', r'defaultOpen' + str(counter), l2_new)
                    else:
                        l1_new = l1
                        l2_new = l2
                    new_lines.append(l1_new)
                    new_lines.append(l2_new)
                    tablinks_list.remove(i+1)
                    counter = counter + 1
                else:
                    if not '<button class="tablinks"' in lines[i]:
                        new_lines.append(lines[i])
            new_content = '\n'.join(new_lines)
    # ...then we remove the {::options parse_block_html="true" /}:
    new_content = re.sub(r'\x7B\x3A{2}options\sparse_block_html=\x22true\x22\s\x2F\x7D\s(\x3Cdiv\sclass=\x22tab-content\x22\x3E)', r'\1', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x7B\x3A{2}options\sparse_block_html=\x22true\x22\s\x2F\x7D\s', r'', new_content, flags=re.MULTILINE | re.DOTALL)
    # The last major step is to find all the {: #cs1 .tab-pane .fade .in. active } and replace with surrounding divs...
    # ...starting with the unnumbered codetab case with and without the final div
    new_content = re.sub(r'(\x3Cdiv class=\x22tab-content\x22\x3E)\s{1,3}(\x60{3}\w{0,8})(.*?)\x60{3}\s(\x7B\x3A\s\x23(\D{1,10})\s\x2Etab-pane \x2Efade \x2Ein.*?\x7D)\s\s(\x60{3}\w{0,8})(.*?)\x60{3}\s(\x7B\x3A\s\x23(\D{1,10})\s\x2Etab-pane \x2Efade \x2Ein.*?\x7D)\s\s(\x3C\x2Fdiv\x3E)', r'\1\n<div class="codetab-content" id="\5">\n\n\2\3\n```\n\n</div>\n\n<div class="codetab-content" id="\9">\n\n\6\7```\n\n\10\n\10', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(\x3Cdiv class=\x22tab-content\x22\x3E)\s{1,3}(\x60{3}\w{0,8})(.*?)\x60{3}\s(\x7B\x3A\s\x23(\D{1,10})\s\x2Etab-pane \x2Efade \x2Ein.*?\x7D)\s\s(\x60{3}\w{0,8})(.*?)\x60{3}\s(\x7B\x3A\s\x23(\D{1,10})\s\x2Etab-pane \x2Efade \x2Ein.*?\x7D)', r'\1\n<div class="codetab-content" id="\5">\n\n\2\3\n```\n\n</div>\n\n<div class="codetab-content" id="\9">\n\n\6\7```\n\n</div>\n/div>', new_content, flags=re.MULTILINE | re.DOTALL)
    # ...and then numbered codetab cases with and without the final div
    new_content = re.sub(r'(\x3Cdiv class=\x22tab-content\x22\x3E)\s{1,3}(\x60{3}\w{0,8})(.*?)\x60{3}\s(\x7B\x3A\s\x23(\D{1,10})(\d{1,10})\s\x2Etab-pane \x2Efade \x2Ein.*?\x7D)\s\s(\x60{3}\w{0,8})(.*?)\x60{3}\s(\x7B\x3A\s\x23(\D{1,10})(\d{1,10})\s\x2Etab-pane \x2Efade \x2Ein.*?\x7D)\s\s(\x3C\x2Fdiv\x3E)', r'\1\n<div class="codetab-content\6" id="\5\6">\n\n\2\3\n```\n\n</div>\n\n<div class="codetab-content\11" id="\10\11">\n\n\7\8```\n\n\12\n\12', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(\x3Cdiv class=\x22tab-content\x22\x3E)\s{1,3}(\x60{3}\w{0,8})(.*?)\x60{3}\s(\x7B\x3A\s\x23(\D{1,10})(\d{1,10})\s\x2Etab-pane \x2Efade \x2Ein.*?\x7D)\s\s(\x60{3}\w{0,8})(.*?)\x60{3}\s(\x7B\x3A\s\x23(\D{1,10})(\d{1,10})\s\x2Etab-pane \x2Efade \x2Ein.*?\x7D)', r'\1\n<div class="codetab-content\6" id="\5\6">\n\n\2\3\n```\n\n</div>\n\n<div class="codetab-content\11" id="\10\11">\n\n\7\8```\n\n</div>\n</div>', new_content, flags=re.MULTILINE | re.DOTALL)
    # and finally we're done with the tab-pane code-block samples

    # Special case: http://localhost:1313/guides/general/essential-mathematics/ - ![/images/math-logo.svg alt >](/images/math-logo.svg)
    new_content = re.sub(r'\x21\x5B\x2Fimages\x2Fmath-logo.svg\salt\s\x3E\x5D\x28\x2Fimages\x2Fmath-logo.svg\x29', r'{{< image url="/images/math-logo.svg" alt="/images/math-logo.svg" class="float_right" >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    
    # Remove extraneous formatting at bottom of tables: |=====
    new_content = re.sub(r'\x7C\x3D{5}\s\x7C\s\s', r'', new_content, flags=re.MULTILINE | re.DOTALL)

    # Special case header missing ## http://localhost:1313/guides/rhinopython/python-editing-scripts/
    new_content = re.sub(r'(The Menu)\s\s(The menu provides access to all the RhinoPythonScript)', r'## \1\n\n\2', new_content, flags=re.MULTILINE | re.DOTALL)

    # Fix typos in closing code blocks - then a bunch of typos
    new_content = re.sub(r'\x60{4}\s\s\x60random\x60', r'```\n\n`random`', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x60{4}\sKeep', r'```\n\nKeep', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(\x23methods-of-file-objects\x29\s)\x60{3}', r'\1', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(\x60{3}\s)(We\x27ve put the action)', r'\1\n\2', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(\x60{3}\s)(section. This allows)', r'\1\n\2', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(\x60{3}\s)----', r'\1', new_content, flags=re.MULTILINE | re.DOTALL)

    # http://localhost:1313/guides/rhinocommon/run-rhino-command-from-plugin/ - contains bad code-tabs with mismatched defaults - reverse order is intentional
    new_content = re.sub(r'tablinks2(\x22\s.*?cs3.*?)defaultOpen2\x22', r'tablinks3\1defaultOpen3"', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'tablinks1(\x22\s.*?cs2.*?)defaultOpen1\x22', r'tablinks2\1defaultOpen2"', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'tablinks(\x22\s.*?cs1.*?)defaultOpen\x22', r'tablinks1\1defaultOpen1"', new_content, flags=re.MULTILINE | re.DOTALL)

    # add call-out wwarnings about being out-of-date to website guides
    warning_text = '{{< call-out "warning" "Transition underway" >}}\nThis site is undergoing a transition from Jekyll to Hugo. This page is out-of-date while this warning is in place.\n{{< /call-out >}}\n\n'
    new_content = re.sub(r'(\x5BThis site\x5D\x28http://developer.rhino3d.com\x29 is hosted on)', warning_text + r'\1', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(Below are examples of nearly all the available syntax)', warning_text + r'\1', new_content, flags=re.MULTILINE | re.DOTALL)

    # http://localhost:1313/guides/rhinopython/primer-101/ - main images are not floated correctly.  Fix Bad link in acknowledgments
    # First delete the old column div
    new_content = re.sub(r'<div class=\x22col-md-4 hidden-sm hidden-xs\x22 markdown=\x221\x22>\s.*?</div>', r'', new_content, flags=re.MULTILINE | re.DOTALL)
    # Insert the first image at the right spot
    new_content = re.sub(r'(You.ve just opened the .*? edition of the .*? primer.)', r'{{< image url="/images/primer-normals.svg" alt="/images/primer-normals.svg" width="30%" class="float_right" >}}\n\n\1', new_content, flags=re.MULTILINE | re.DOTALL)
    # Insert the second in the paragraph below that one...
    new_content = re.sub(r'(Similar to the previous primers, we have the advantage)', r'{{< div class="clear_both" />}}\n\n{{< image url="/images/primer-branchpropagation2.svg" alt="/images/primer-branchpropagation2.svg" width="30%" class="float_right" >}}\n\n\1', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(The one advantage I enjoy over authors of other programming books)', r'{{< div class="clear_both" />}}\n\n{{< image url="/images/primer-branchpropagation2.svg" alt="/images/primer-branchpropagation2.svg" width="30%" class="float_right" >}}\n\n\1', new_content, flags=re.MULTILINE | re.DOTALL)
    # Make the autograph smaller
    new_content = re.sub(r'(primer-autograph.svg\x22\swidth=\x22)70%\x22', r'primer-autograph.svg" width="40%"', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(.A special thanks to David Rutten for the inspiration)', r'\n\1', new_content, flags=re.MULTILINE | re.DOTALL)
    # Fix authors columns
    new_content = re.sub(r'(\x3Cdiv class=\x22row\x22\x3E\s\s)(.*?Tibbits)', r'{{< row >}}\n\2', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(Baer\x2A{2}\x3Cbr\x2F\x3E.*?)(\x3C\x2Fdiv\x3E)', r'\1{{< /row >}}', new_content, flags=re.MULTILINE | re.DOTALL)

    # Under construction warnings
    warning_text = '{{< call-out "danger" "Under Construction" >}}\nThis guide has yet to be ported to this site. Please check back soon for updates.\n{{< /call-out >}}\n\n'
    new_content = re.sub(r'(\x3Cdiv\sclass=\x22bs-callout\sbs-callout-danger\x22\x3E\s.*?UNDER\sCONSTRUCTION.*?\x3C\x2Fdiv\x3E)', warning_text, new_content, flags=re.MULTILINE | re.DOTALL)

    # http://localhost:1313/guides/rhinopython/primer-101/8-geometry/ - fix errant line-numbers divs
    # http://localhost:1313/guides/rhinoscript/primer-101/7-geometry/ - fix errant line-numbers divs
    new_content = re.sub(r'(rs.EnableRedraw.True.\s)\x7B{2}\x3C\sdiv\sclass=\x22line-numbers\x22\s\x3E\x7D{2}\s\x60{3}', r'\1\n```\n', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(End Sub\s)\x7B{2}\x3C\sdiv\sclass=\x22line-numbers\x22\s\x3E\x7D{2}\s\x60{3}', r'\1\n```\n', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(VectorDotProduct.D.\sBisector.\s)\x7B{2}\x3C\sdiv\sclass=\x22line-numbers\x22\s\x3E\x7D{2}\s\x60{3}', r'\1```\n', new_content, flags=re.MULTILINE | re.DOTALL)

    # http://localhost:1313/guides/cpp/defining-new-plugin-commands/ - broken image
    new_content = re.sub(r'your_first_plugin_windows_cpp_07.png', r'your-first-plugin-windows-cpp-07.png', new_content, flags=re.MULTILINE | re.DOTALL)

    # {{ site.nwo }} links
    new_content = re.sub(r'https://github.com/\x7B{2}\ssite.nwo\s\x7D{2}/blob/\x7B{2}\ssite.git_branch\s\x7D{2}/\x7B{2}\spage.path\s\x7D{2}', r'https://github.com/mcneel/developer-rhino3d-com/blob/main/content/en/guides/general/how-this-site-works/index.md', new_content, flags=re.MULTILINE | re.DOTALL)

    # http://localhost:1313/guides/rhinocommon/your-first-plugin-windows/ - window too wide
    # http://localhost:1313/guides/rhinocommon/your-first-plugin-mac/ - window too wide
    new_content = re.sub(r'\s{8}(RhinoApp.WriteLine\s..The distance between the two points is .*?Length\x29\x3B)', r'```cs\n\1\n```\n', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\s{8}(RhinoApp.WriteLine\s..The distance between the two points is .*?ToLower\x28\x29\x29\x3B)', r'```cs\n\1\n```\n', new_content, flags=re.MULTILINE | re.DOTALL)

    # http://localhost:1313/guides/rhinopython/python-operators/ - table clean up
    # http://localhost:1313/guides/rhinoscript/vbscript-operators/ - table clean up
    new_content = re.sub(r'\s\x7C--\s\s\x7c\sDescription\s\x7C\s.*?\x7C\s{0,1}Symbol\s\x7C\s\s\x7C--', r'| Description |      | Symbol |\n| :---------- | ---- | -----: |', new_content, flags=re.MULTILINE | re.DOTALL)

    # http://localhost:1313/guides/rhinopython/ - remove snagit image at bottom of page
    new_content = re.sub(r'\x3C\x21--the\s.snagit\sproject\sfor.this.image.can.be.found.next.to.the.image.--\x3E\s{0,2}\x5B\x3Cimg.src=\x22/images/rhinopython-guides-col3.png\x22\x3E\x5D\x28http://www.rhino3d.com/download/IronPython/5.0/RhinoPython101\x29(\s\s\x7B{2})', r'\1', new_content, flags=re.MULTILINE | re.DOTALL)

    # {{ site.git_branch | default: "master" }}
    new_content = re.sub(r'\x7B{2}\ssite.git_branch\s.\sdefault.\s\x22master\x22\s\x7D{2}', r'master', new_content, flags=re.MULTILINE | re.DOTALL)

    # http://localhost:1313/guides/rhinoscript/primer-101/2-vbscript-essentials/ - table formatting wrong
    new_content = re.sub(r'\x7C\smov\s\x7C\s\x7C\s\x7C.*?esp,\s8\s\x7C', r'|   |  |  |   |\n| :--- | --- | --- | -------------: |\n| mov  | [ebx], ecx     |\n| add  | ebx, 4         |\n| loop | init_loop      |\n| push | dword FirstMsg |\n| call | _puts          |\n| pop  | ecx            |\n| push | dword 10       |\n| push | dword array    |\n| call | _print_array   |\n| add  | esp, 8         |\n', new_content, flags=re.MULTILINE | re.DOTALL)
    
    # http://localhost:1313/guides/rhinoscript/getting-and-setting-locale/ - table formatting wrong
    new_content = re.sub(r'\x7C--\s\x7C\sCulture\s\x7C.*?\x27567.89\s\x7C', r'| Culture       |   Format     |\n| :------------ | -----------: |\n| United States | 1,234,567.89 |\n| France        | 1 234 567,89 |\n| German        | 1.234.567,89 |\n| Switzerland   | 1’234’567.89 |\n', new_content, flags=re.MULTILINE | re.DOTALL)
    
    # http://localhost:1313/guides/cpp/loading-plugins-at-startup/ - table formatting wrong
    new_content = re.sub(r'\x7C\s:-------------\s\x7C\s\x7C\s\x7C\s:-------------\s\x7C\s\x7C \x7C\s:-------------\s\x7C', r'| :------------- | --- | --- | :------------- | --- | --- | :------------- |', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(Load when Rhino is loaded)\s\s{0,7}\x7C', r'\1 |', new_content, flags=re.MULTILINE | re.DOTALL)

    # http://localhost:1313/guides/cpp/your-first-plugin-windows/ - window too wide
    new_content = re.sub(r'\s{8}RHINO_PLUG_IN_', r'RHINO_PLUG_IN_', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(RHINO_PLUG_IN_DEVELOPER_ORGANIZATION.*?mycompany.com/support\x22\x29\x3B)', r'```cpp\n\1\n```', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\s{4}(\x21\x5BRhino\sOptions\x5D\x28/images/your-first-plugin-windows-cpp-07.png\x29)', r'\1', new_content, flags=re.MULTILINE | re.DOTALL)

    # Fix typos
    new_content = re.sub(r'availabe', r'available', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'RhinoScritSyntax', r'RhinoScriptSyntax', new_content, flags=re.MULTILINE | re.DOTALL)

    # Add missing codeblock language specifiers
    new_content = re.sub(r'(```)(\sconst\sON_SubD\x2A\ssubd\s=\sON_SubD\x3A{2}Cast)', r'\1cpp\2', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'(```)(\s//\sGets a ON_Brep representation the subdivision limit surface)', r'\1cpp\2', new_content, flags=re.MULTILINE | re.DOTALL)

    # {{ site.rhino.mac_path }} -> -> /Applications/Rhino x.app
    new_content = re.sub(r'\x7B{2}\ssite.rhino.mac_path\s\x7D{2}', r'/Applications/Rhino {{< latest-rhino-version >}}.app', new_content, flags=re.MULTILINE | re.DOTALL)

    # {{ site.rhino.windows_path }} -> C:\Program Files\Rhino x
    new_content = re.sub(r'\x7B{2}\ssite.rhino.windows_path\s\x7D{2}', r'C:\\Program Files\\Rhino {{< latest-rhino-version >}}', new_content, flags=re.MULTILINE | re.DOTALL)

    # {% include yak-mac-path-note.html %}
    new_content = re.sub(r'\x7B\x25\sinclude\syak-mac-path-note.html\s\x25\x7D', r'', new_content, flags=re.MULTILINE | re.DOTALL)

    # handle call-outs, mostly in yak pages
    new_content = re.sub(r'\x3Cdiv\sclass=\x22alert\salert-info\x22\srole=\x22alert\x22\x3E\s(.*?)\x3C/div\x3E', r'{{< call-out "note" "Note" >}}\n\1{{< /call-out >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x3Cdiv\sclass=\x22alert\salert-warning\x22\srole=\x22alert\x22\x3E\s(.*?)\x3C/div\x3E', r'{{< call-out "warning" "Warning" >}}\n\1{{< /call-out >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x3Cdiv\sclass=\x22alert\salert-danger\x22\srole=\x22alert\x22\x3E\s(.*?)\x3C/div\x3E', r'{{< call-out "danger" "Danger" >}}\n\1{{< /call-out >}}', new_content, flags=re.MULTILINE | re.DOTALL)
    new_content = re.sub(r'\x3Cstrong\x3ENote:\x3C/strong\x3E\s', r'', new_content, flags=re.MULTILINE | re.DOTALL) # Remove redundant words

    # Handle bad formatting in yak guide
    new_content = re.sub(r'\x3Cbr\x3E\x3Cbr\x3E\s\x3Cpre\x3E\x3Ccode\sclass=\x22language-commandline\x22\x3E\s\x26gt\x3B\s(.*?)\x26gt\x3B\s(.*?)\x3C/code\x3E\x3C/pre\x3E\s\x3Cbr\x3E\x3Cbr\x3E', r'```cmd\n\1\2```', new_content, flags=re.MULTILINE | re.DOTALL)

    # Remove WIP warning from bottom of index (home) page
    new_content = re.sub(r'\x3Cp\x3E\x3Ci\x3EWARNING\x3C/i\x3E: This is the Work-In-Progress version of this site & should not be considered stable. \x3Ca href=\x22\x7B{2}site.baseurl_orig\x7D{2}\x7B{2} page.url \x7D{2}\x22\x3EView the current stable version instead.\x3C/a\x3E\x3C/p\x3E', r'', new_content, flags=re.MULTILINE | re.DOTALL)
    
    return new_content


def convert_markdown_file(file_to_convert):
    global old_root
    new_content = ""

    new_frontmatter_section = " "
    new_content_section = " "

    # Separate the yml frontmatter from the content
    old_file = open(file_to_convert, "r")
    old_frontmatter_section = ''
    old_content_section = ''
    
    found_seperators = 0
    for line in old_file:
        if found_seperators < 2:
            old_frontmatter_section += line 
            if line.startswith("---\n"):
                found_seperators = found_seperators + 1
        else:
            old_content_section += line
    
    old_file.close()

    # If this is a guide or sample, we should calculate the override_last_modified date and add that to the frontmatter
    override_last_modified = ''
    if not debugging: # this process is kinda slow, so only do this at the end
        if ('_guide_topics' in file_to_convert) or ('_samples' in file_to_convert):
            git_log_argument = 'git log -1 --pretty="format:%ci" ' + file_to_convert
            git_log_process = subprocess.Popen([git_log_argument], cwd=old_root, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)
            git_last_updated, err = git_log_process.communicate()
            
            if git_last_updated:
                git_last_updated = str(git_last_updated.decode())
                hugo_date_format = git_last_updated.split(" ")[0] + 'T' + git_last_updated.split(" ")[1] + 'Z'

                override_last_modified = hugo_date_format

    # Convert frontmatter
    new_fontmatter_section = convert_frontmatter(old_frontmatter_section, override_last_modified)

    # Convert markdown
    new_content_section = convert_markdown_content(old_content_section)

    # Put the frontmatter and the content together
    new_content = new_fontmatter_section + new_content_section

    return new_content


def convert_path_list(list_of_file_paths, src_folder, dest_folder):
    for old_file_path in list_of_file_paths:
        old_file_title = os.path.basename(old_file_path).split(".md")[0]
        
        # Create a folder based on the name of the old file in the right spot
        new_subpath = old_file_path.split(src_folder + "/")[1].split(".md")[0]
        new_file_folder_path = os.path.abspath(os.path.join(dest_folder, new_subpath))
        if not os.path.exists(new_file_folder_path):
            os.makedirs(new_file_folder_path)
            
        # Check to see if there is a folder that matches the name of the old file, if so, it's an index page
        is_index_page = False
        path_to_check = os.path.abspath(os.path.join(src_folder, new_subpath))
        if os.path.exists(path_to_check):
            if os.path.isdir(path_to_check):
                is_index_page = True
            
        new_file_path = ""
        if is_index_page:
            new_file_path = os.path.abspath(os.path.join(new_file_folder_path, "_index.md"))
        else:
            new_file_path = os.path.abspath(os.path.join(new_file_folder_path, "index.md"))

        print("Converting: " + new_subpath + "...")
        new_content = convert_markdown_file(old_file_path)
        new_file = open(new_file_path, "w")
        new_file.write(new_content)
        new_file.close()


# Main handlers --------------------------------------------------------------------------------------------------------
def handle_homepage():
    print("Port homepage (index) from jekyll to hugo...")
    old_content_homepage_path = os.path.abspath(os.path.join(old_root, "index.md"))
    new_content_homepage_path = os.path.abspath(os.path.join(new_content_root_path, "_index.md"))

    new_content = convert_markdown_file(old_content_homepage_path)
    new_homepage_index_file = open(new_content_homepage_path, "w")
    
    # add top-level list_group for multi-page TOCs
    new_content = re.sub(r'\s{1}(\+\+\+)', r'\n[cascade]\nlist_group = "uncategorized"\n\1', new_content, flags=re.MULTILINE | re.DOTALL)
    
    # Force left-aligned table headings:
    new_content = re.sub(r'(\x3Cth)\x3E', r'\1 style="text-align: left;">', new_content, flags=re.MULTILINE | re.DOTALL)

    # Add padding to the top and bottom of the tagline at the bottom
    new_content = re.sub(r'(\x7B{2}\x3C\scenter\s\x3E\x7D{2}\s\s)(Rhino developer tools are royalty free and include support.)', r'\1{{< div class="index_free_support" >}}\n\2\n{{< /div >}}', new_content, flags=re.MULTILINE | re.DOTALL)

    new_homepage_index_file.write(new_content)
    new_homepage_index_file.close()

    print_ok_message("homepage (index) successfully ported to hugo.")


def handle_authors():
    print("Porting authors from jekyll to hugo...")
    old_content_authors_paths = get_markdown_files_list(old_content_authors_root_path)
    
    # make sure the /contents/en/authors section exists and create it if it doesn't
    new_content_authors_root_path = os.path.abspath(os.path.join(new_content_root_path, "authors"))
    if not os.path.exists(new_content_authors_root_path):
        print_warning_message(new_content_authors_root_path + " does not exists, creating it")
        os.makedirs(new_content_authors_root_path)

    # Handle _authors index (new: /content/en/authors/_index.md)
    old_authors_index_path = os.path.abspath(os.path.join(old_root, "authors.md"))
    new_authors_index_path = os.path.abspath(os.path.join(new_content_authors_root_path, "_index.md"))
    new_content = convert_markdown_file(old_authors_index_path)
    # make sure the authors page uses the correct authors layout template
    new_content = re.sub(r'type\s=\s\x22guides\x22', r'type = "authors"', new_content, flags=re.MULTILINE | re.DOTALL)
    # remove old authors list generation
    new_content = re.sub(r'\x3Cdiv\sclass=\x22trigger\x22\x3E\s.*?\x3C\x2Fdiv\x3E', r'', new_content, flags=re.MULTILINE | re.DOTALL)
    new_authors_index_file = open(new_authors_index_path, "w")
    new_authors_index_file.write(new_content)
    new_authors_index_file.close()

    # Create folders for each author and put the default layout file in it.
    for old_author_path in old_content_authors_paths:
        old_author = os.path.basename(old_author_path).split(".")[0].strip()
        new_author = authors_mapping[old_author]
        new_author_path = os.path.abspath(os.path.join(new_content_authors_root_path, new_author))
        log_redirect_url("/authors/" + old_author, "/authors/" + new_author)
        if not os.path.exists(new_author_path):
            print_warning_message(new_author_path + " does not exists, creating it")
            os.makedirs(new_author_path)
        
        new_author_content_path = os.path.abspath(os.path.join(new_author_path, "index.md"))
        new_index_file = open(new_author_content_path, "w")
        index_file_contents = ['+++', 'type = \"authors\"', '+++']
        new_index_file.write('\n'.join(index_file_contents) + '\n')
        new_index_file.close()

    print_ok_message("authors successfully ported to hugo.")


def handle_guides():
    print("Porting guides from jekyll to hugo...")
    old_content_guides_paths = get_markdown_files_list(old_content_guides_root_path)

    # make sure the /contents/en/guides section exists and create it if it doesn't
    new_content_guides_root_path = os.path.abspath(os.path.join(new_content_root_path, "guides"))
    if not os.path.exists(new_content_guides_root_path):
        print_warning_message(new_content_guides_root_path + " does not exists, creating it")
        os.makedirs(new_content_guides_root_path)

    # copy over the old folder structure "as is"
    copy_folder_tree_without_files(old_content_guides_root_path, new_content_guides_root_path)

    # grab the guides index page
    guides_index_path_old = os.path.abspath(os.path.join(old_root, "guides.md"))
    guides_index_path_new = os.path.abspath(os.path.join(new_content_guides_root_path, "_index.md"))
    print("Converting: /guides.md ...")
    new_content = convert_markdown_file(guides_index_path_old)
    new_file = open(guides_index_path_new, "w")
    new_content = re.sub(r'#\sGuides', r'', new_content) #remove redundant title
    new_file.write(new_content)
    new_file.close()

    # perform the conversion...
    convert_path_list(old_content_guides_paths, old_content_guides_root_path, new_content_guides_root_path)

    print_ok_message("guides successfully ported to hugo.")

    
def handle_samples():
    print("Porting samples from jekyll to hugo...")
    old_content_samples_paths = get_markdown_files_list(old_content_samples_root_path)
    
    # make sure the /contents/en/samples section exists and create it if it doesn't
    new_content_samples_root_path = os.path.abspath(os.path.join(new_content_root_path, "samples"))
    if not os.path.exists(new_content_samples_root_path):
        print_warning_message(new_content_samples_root_path + " does not exists, creating it")
        os.makedirs(new_content_samples_root_path)

    # copy over the old folder structure "as is"
    copy_folder_tree_without_files(old_content_samples_root_path, new_content_samples_root_path)

    # grab the samples index page
    samples_index_path_old = os.path.abspath(os.path.join(old_root, "samples.md"))
    samples_index_path_new = os.path.abspath(os.path.join(new_content_samples_root_path, "_index.md"))
    print("Converting: /samples.md ...")
    new_content = convert_markdown_file(samples_index_path_old)
    new_file = open(samples_index_path_new, "w")
    new_content = re.sub(r'#\sSamples', r'', new_content) #remove redundant title
    new_file.write(new_content)
    new_file.close()

    # perform the conversion...
    convert_path_list(old_content_samples_paths, old_content_samples_root_path, new_content_samples_root_path)

    print_ok_message("samples successfully ported to hugo.")


def handle_api():
    print("Porting api page from jekyll to hugo...")
    global old_content_api_page_path
    
    # make sure the /contents/en/api section exists and create it if it doesn't
    new_content_api_root_path = os.path.abspath(os.path.join(new_content_root_path, "api"))
    if not os.path.exists(new_content_api_root_path):
        print_warning_message(new_content_api_root_path + " does not exists, creating it")
        os.makedirs(new_content_api_root_path)
    
    new_content_api_page_path = os.path.abspath(os.path.join(new_content_api_root_path, "_index.md"))

    print("Converting: /api.md ...")
    new_content = convert_markdown_file(old_content_api_page_path)
    new_file = open(new_content_api_page_path, "w")

    # Special cases for API page...
    new_content = re.sub(r'#\sAPI References  ', r'', new_content) # remove redundant title
    new_content = re.sub(r'title = \"API\"', r'title = "API References"', new_content) # add proper title    
    new_content = re.sub(r'<span class="glyphicon glyphicon-new-window" aria-hidden="true"></span>', r'{{< awesome "fas fa-external-link-alt" >}}', new_content)
    
    new_file.write(new_content)
    new_file.close()

    print_ok_message("api successfully ported to hugo.")


def handle_images():
    print("Porting images and resources content from old site to new...")

    shutil.copytree(old_images_root_path, new_images_root_path, dirs_exist_ok=True)

    print_ok_message("images and resources ported to new site.")


def handle_videos():
    print("Porting videos page from old site to new...")
    global old_content_videos_page_path

    # make sure the /contents/en/videos section exists and create it if it doesn't
    new_content_video_root_path = os.path.abspath(os.path.join(new_content_root_path, "videos"))
    if not os.path.exists(new_content_video_root_path):
        print_warning_message(new_content_video_root_path + " does not exists, creating it")
        os.makedirs(new_content_video_root_path)
    
    new_content_video_page_path = os.path.abspath(os.path.join(new_content_video_root_path, "_index.md"))

    print("Converting: /videos.md ...")
    new_content = convert_markdown_file(old_content_videos_page_path)
    new_file = open(new_content_video_page_path, "w")
    new_content = re.sub(r'#\sVideos', r'', new_content) #remove redundant title
    new_file.write(new_content)
    new_file.close()

    print_ok_message("videos page successfully ported to hugo.")


def handle_files_folder():
    print("Porting files content from old site to new...")

    shutil.copytree(old_files_root_path, new_files_root_path, dirs_exist_ok=True)

    print_ok_message("files ported to new site.")


def handle_rhinoscript_syntax_api():
    print("Processing rhinoscriptsyntax data...")

    # open and read the rhinoscriptsyntax.json file
    path_to_rhinoscriptsyntax_json = os.path.abspath(os.path.join(new_content_data_path, "rhinoscriptsyntax.json"))
    rs_json_file = open(path_to_rhinoscriptsyntax_json)
    modules = json.load(rs_json_file)

    for module in modules:
        new_content_api_root_path = os.path.abspath(os.path.join(new_content_root_path, "api"))
        rhinoscriptsyntax_root_path = os.path.abspath(os.path.join(new_content_api_root_path, "RhinoScriptSyntax"))
        
        # make the module folder
        new_module_folder_path = os.path.abspath(os.path.join(rhinoscriptsyntax_root_path, module["ModuleName"]))
        if not os.path.exists(new_module_folder_path):
            os.makedirs(new_module_folder_path)
        
        # add the module index.md file
        module_index_path = os.path.abspath(os.path.join(new_module_folder_path, "index.md"))
        f = open(module_index_path, "w")

        # write the frontmatter
        f.write('+++\n')
        f.write('Title = \"' + module["ModuleName"] + '\"\n')
        f.write('type = \"guides\"\n')
        #f.write('list_group = \"' + module["ModuleName"] + ' module \"\n\n')
        f.write('[page_options]\n')
        f.write('byline = false\n')
        f.write('toc = true\n')
        f.write('toc_type = \"multi\"\n')
        f.write('+++\n\n')

        for function in module["functions"]:
            f.write('## ' + function["Name"] + '\n\n')
            f.write('```py\n')
            f.write(function["Signature"]  + '\n')
            f.write('```\n\n')
            description = function["Description"].replace('\r\n    ', '')
            f.write(description + '\n\n')
            if function["HasArguments"]:
                f.write('**Parameters:**\n\n')
                f.write('```\n')
                f.write(function["ArgumentDesc"]  + '\n')
                f.write('```\n\n')
            if function["ReturnStr"]:
                f.write('**Returns:**\n\n')
                f.write('```\n')
                f.write(function["ReturnStr"]  + '\n')
                f.write('```\n\n')
            if function["ExampleString"]:
                f.write('**Example:**\n\n')
                f.write('```py\n')
                f.write(function["ExampleString"]  + '\n')
                f.write('```\n\n')
            if len(function["SeeAlso"]) > 0:
                f.write('**See Also:**\n\n')
                for entry in function["SeeAlso"]:
                    moduleName = ''
                    if not entry["ModuleName"]:
                        moduleName = module["ModuleName"]
                    else:
                        moduleName = entry["ModuleName"]
                    f.write('* [' + entry["FunctionName"] + '](/api/RhinoScriptSyntax/' + moduleName + '/#' + entry["FunctionName"].lower() + ')\n')
                f.write('\n')
        
        f.close()
    
    rs_json_file.close()

    print_ok_message("done processing rhinoscriptsyntax data.")


def audit_frontmatter():
    global frontmatter_key_mapping
    global yaml_keys_to_ignore
    print("Auditing frontmatter...")
    print("  The following yaml frontmatter keys were found:")
    for key in frontmatter_key_mapping:
        print("    " + key)
    
    print("  The following yaml keys were ignored:")
    for key in yaml_keys_to_ignore:
        print("    " + key)

    # Check for missing mappings
    missing_mappings = {}
    for key, value in frontmatter_key_mapping.items():
        if "[missing]" in value:
            missing_mappings[key] = value
    if missing_mappings:
        print("  The following yaml keys DO NOT have a toml mapping value:")
        for key, value in missing_mappings.items():
            print("    " + key + " -> " + value)


def main():
    #handle_homepage()
    #handle_authors()
    #handle_guides()
    #handle_samples()
    #handle_api()
    #handle_images()
    #handle_files_folder()
    #handle_videos()
    #audit_frontmatter()
    handle_rhinoscript_syntax_api()

if __name__ == "__main__":
    main()
